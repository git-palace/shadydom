'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

(function () {
  'use strict';

  /**
  @license
  Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */

  var settings = window.ShadyDOM || {};

  settings.hasNativeShadowDOM = Boolean(Element.prototype.attachShadow && Node.prototype.getRootNode);

  var desc = Object.getOwnPropertyDescriptor(Node.prototype, 'firstChild');

  settings.hasDescriptors = Boolean(desc && desc.configurable && desc.get);
  settings.hasNerfedDescriptors = Boolean(desc && !settings.hasDescriptors);

  settings.inUse = settings.force || !settings.hasNativeShadowDOM;

  function isShadyRoot(obj) {
    return Boolean(obj.__localName === 'ShadyRoot');
  }

  var p = Element.prototype;
  var matches = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;

  function matchesSelector(element, selector) {
    return matches.call(element, selector);
  }

  function copyOwnProperty(name, source, target) {
    var pd = Object.getOwnPropertyDescriptor(source, name);
    if (pd) {
      Object.defineProperty(target, name, pd);
    }
  }

  function extend(target, source) {
    if (target && source) {
      var n$ = Object.getOwnPropertyNames(source);
      for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
        copyOwnProperty(n, source, target);
      }
    }
    return target || source;
  }

  function extendAll(target) {
    for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      sources[_key - 1] = arguments[_key];
    }

    for (var i = 0; i < sources.length; i++) {
      extend(target, sources[i]);
    }
    return target;
  }

  function mixin(target, source) {
    for (var i in source) {
      target[i] = source[i];
    }
    return target;
  }

  var setPrototypeOf = Object.setPrototypeOf || function (obj, proto) {
    obj.__proto__ = proto;
    return obj;
  };

  function patchPrototype(obj, mixin) {
    var proto = Object.getPrototypeOf(obj);
    if (!proto.hasOwnProperty('__patchProto')) {
      var _patchProto = Object.create(proto);
      _patchProto.__sourceProto = proto;
      extend(_patchProto, mixin);
      proto.__patchProto = _patchProto;
    }
    setPrototypeOf(obj, proto.__patchProto);
  }

  // TODO(sorvell): actually rely on a real Promise polyfill...
  var promish = void 0;
  if (window.Promise) {
    promish = Promise.resolve();
  } else {
    (function () {
      var twiddle = document.createTextNode('');
      var content = 0;
      promish = {
        then: function then(cb) {
          // To preserve timing with Promise microtasks
          // we create a new observer for every callback.
          var observer = new MutationObserver(function () {
            observer.disconnect();
            cb();
          });
          observer.observe(twiddle, { characterData: true });
          twiddle.textContent = content++;
        }
      };
    })();
  }

  /**
  @license
  Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */

  function newSplice(index, removed, addedCount) {
    return {
      index: index,
      removed: removed,
      addedCount: addedCount
    };
  }

  var EDIT_LEAVE = 0;
  var EDIT_UPDATE = 1;
  var EDIT_ADD = 2;
  var EDIT_DELETE = 3;

  var ArraySplice = {

    // Note: This function is *based* on the computation of the Levenshtein
    // "edit" distance. The one change is that "updates" are treated as two
    // edits - not one. With Array splices, an update is really a delete
    // followed by an add. By retaining this, we optimize for "keeping" the
    // maximum array items in the original array. For example:
    //
    //   'xxxx123' -> '123yyyy'
    //
    // With 1-edit updates, the shortest path would be just to update all seven
    // characters. With 2-edit updates, we delete 4, leave 3, and add 4. This
    // leaves the substring '123' intact.
    calcEditDistances: function calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd) {
      // "Deletion" columns
      var rowCount = oldEnd - oldStart + 1;
      var columnCount = currentEnd - currentStart + 1;
      var distances = new Array(rowCount);

      // "Addition" rows. Initialize null column.
      for (var i = 0; i < rowCount; i++) {
        distances[i] = new Array(columnCount);
        distances[i][0] = i;
      }

      // Initialize null row
      for (var j = 0; j < columnCount; j++) {
        distances[0][j] = j;
      }for (var _i = 1; _i < rowCount; _i++) {
        for (var _j = 1; _j < columnCount; _j++) {
          if (this.equals(current[currentStart + _j - 1], old[oldStart + _i - 1])) distances[_i][_j] = distances[_i - 1][_j - 1];else {
            var north = distances[_i - 1][_j] + 1;
            var west = distances[_i][_j - 1] + 1;
            distances[_i][_j] = north < west ? north : west;
          }
        }
      }

      return distances;
    },


    // This starts at the final weight, and walks "backward" by finding
    // the minimum previous weight recursively until the origin of the weight
    // matrix.
    spliceOperationsFromEditDistances: function spliceOperationsFromEditDistances(distances) {
      var i = distances.length - 1;
      var j = distances[0].length - 1;
      var current = distances[i][j];
      var edits = [];
      while (i > 0 || j > 0) {
        if (i == 0) {
          edits.push(EDIT_ADD);
          j--;
          continue;
        }
        if (j == 0) {
          edits.push(EDIT_DELETE);
          i--;
          continue;
        }
        var northWest = distances[i - 1][j - 1];
        var west = distances[i - 1][j];
        var north = distances[i][j - 1];

        var min = void 0;
        if (west < north) min = west < northWest ? west : northWest;else min = north < northWest ? north : northWest;

        if (min == northWest) {
          if (northWest == current) {
            edits.push(EDIT_LEAVE);
          } else {
            edits.push(EDIT_UPDATE);
            current = northWest;
          }
          i--;
          j--;
        } else if (min == west) {
          edits.push(EDIT_DELETE);
          i--;
          current = west;
        } else {
          edits.push(EDIT_ADD);
          j--;
          current = north;
        }
      }

      edits.reverse();
      return edits;
    },


    /**
     * Splice Projection functions:
     *
     * A splice map is a representation of how a previous array of items
     * was transformed into a new array of items. Conceptually it is a list of
     * tuples of
     *
     *   <index, removed, addedCount>
     *
     * which are kept in ascending index order of. The tuple represents that at
     * the |index|, |removed| sequence of items were removed, and counting forward
     * from |index|, |addedCount| items were added.
     */

    /**
     * Lacking individual splice mutation information, the minimal set of
     * splices can be synthesized given the previous state and final state of an
     * array. The basic approach is to calculate the edit distance matrix and
     * choose the shortest path through it.
     *
     * Complexity: O(l * p)
     *   l: The length of the current array
     *   p: The length of the old array
     */
    calcSplices: function calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd) {
      var prefixCount = 0;
      var suffixCount = 0;
      var splice = void 0;

      var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
      if (currentStart == 0 && oldStart == 0) prefixCount = this.sharedPrefix(current, old, minLength);

      if (currentEnd == current.length && oldEnd == old.length) suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);

      currentStart += prefixCount;
      oldStart += prefixCount;
      currentEnd -= suffixCount;
      oldEnd -= suffixCount;

      if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0) return [];

      if (currentStart == currentEnd) {
        splice = newSplice(currentStart, [], 0);
        while (oldStart < oldEnd) {
          splice.removed.push(old[oldStart++]);
        }return [splice];
      } else if (oldStart == oldEnd) return [newSplice(currentStart, [], currentEnd - currentStart)];

      var ops = this.spliceOperationsFromEditDistances(this.calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));

      splice = undefined;
      var splices = [];
      var index = currentStart;
      var oldIndex = oldStart;
      for (var i = 0; i < ops.length; i++) {
        switch (ops[i]) {
          case EDIT_LEAVE:
            if (splice) {
              splices.push(splice);
              splice = undefined;
            }

            index++;
            oldIndex++;
            break;
          case EDIT_UPDATE:
            if (!splice) splice = newSplice(index, [], 0);

            splice.addedCount++;
            index++;

            splice.removed.push(old[oldIndex]);
            oldIndex++;
            break;
          case EDIT_ADD:
            if (!splice) splice = newSplice(index, [], 0);

            splice.addedCount++;
            index++;
            break;
          case EDIT_DELETE:
            if (!splice) splice = newSplice(index, [], 0);

            splice.removed.push(old[oldIndex]);
            oldIndex++;
            break;
        }
      }

      if (splice) {
        splices.push(splice);
      }
      return splices;
    },
    sharedPrefix: function sharedPrefix(current, old, searchLength) {
      for (var i = 0; i < searchLength; i++) {
        if (!this.equals(current[i], old[i])) return i;
      }return searchLength;
    },
    sharedSuffix: function sharedSuffix(current, old, searchLength) {
      var index1 = current.length;
      var index2 = old.length;
      var count = 0;
      while (count < searchLength && this.equals(current[--index1], old[--index2])) {
        count++;
      }return count;
    },
    calculateSplices: function calculateSplices(current, previous) {
      return this.calcSplices(current, 0, current.length, previous, 0, previous.length);
    },
    equals: function equals(currentValue, previousValue) {
      return currentValue === previousValue;
    }
  };

  var calculateSplices = function calculateSplices(current, previous) {
    return ArraySplice.calculateSplices(current, previous);
  };

  /**
  @license
  Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */

  // render enqueuer/flusher
  var customElements$1 = window.customElements;
  var flushList = [];
  var scheduled = void 0;
  var flushCount = 0;
  var flushMax = 100;
  function enqueue(callback) {
    if (!scheduled) {
      scheduled = true;
      promish.then(flush);
    }
    flushList.push(callback);
  }

  function flush() {
    scheduled = false;
    flushCount++;
    while (flushList.length) {
      flushList.shift()();
    }
    if (customElements$1 && customElements$1.flush) {
      customElements$1.flush();
    }
    // continue flushing after elements are upgraded...
    var isFlushedMaxed = flushCount > flushMax;
    if (flushList.length && !isFlushedMaxed) {
      flush();
    }
    flushCount = 0;
    if (isFlushedMaxed) {
      throw new Error('Loop detected in ShadyDOM distribution, aborting.');
    }
  }

  flush.list = flushList;

  /**
  @license
  Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */

  // Cribbed from ShadowDOM polyfill
  // https://github.com/webcomponents/webcomponentsjs/blob/master/src/ShadowDOM/wrappers/HTMLElement.js#L28
  /////////////////////////////////////////////////////////////////////////////
  // innerHTML and outerHTML

  // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#escapingString
  var escapeAttrRegExp = /[&\u00A0"]/g;
  var escapeDataRegExp = /[&\u00A0<>]/g;

  function escapeReplace(c) {
    switch (c) {
      case '&':
        return '&amp;';
      case '<':
        return '&lt;';
      case '>':
        return '&gt;';
      case '"':
        return '&quot;';
      case '\xA0':
        return '&nbsp;';
    }
  }

  function escapeAttr(s) {
    return s.replace(escapeAttrRegExp, escapeReplace);
  }

  function escapeData(s) {
    return s.replace(escapeDataRegExp, escapeReplace);
  }

  function makeSet(arr) {
    var set = {};
    for (var i = 0; i < arr.length; i++) {
      set[arr[i]] = true;
    }
    return set;
  }

  // http://www.whatwg.org/specs/web-apps/current-work/#void-elements
  var voidElements = makeSet(['area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr']);

  var plaintextParents = makeSet(['style', 'script', 'xmp', 'iframe', 'noembed', 'noframes', 'plaintext', 'noscript']);

  function getOuterHTML(node, parentNode, composed) {
    switch (node.nodeType) {
      case Node.ELEMENT_NODE:
        {
          var tagName = node.localName;
          var s = '<' + tagName;
          var attrs = node.attributes;
          for (var i = 0, attr; attr = attrs[i]; i++) {
            s += ' ' + attr.name + '="' + escapeAttr(attr.value) + '"';
          }
          s += '>';
          if (voidElements[tagName]) {
            return s;
          }
          return s + getInnerHTML(node, composed) + '</' + tagName + '>';
        }
      case Node.TEXT_NODE:
        {
          var data = node.data;
          if (parentNode && plaintextParents[parentNode.localName]) {
            return data;
          }
          return escapeData(data);
        }
      case Node.COMMENT_NODE:
        {
          return '<!--' + node.data + '-->';
        }
      default:
        {
          window.console.error(node);
          throw new Error('not implemented');
        }
    }
  }

  function getInnerHTML(node, composed) {
    if (node.localName === 'template') {
      node = node.content;
    }
    var s = '';
    var c$ = composed ? composed(node) : node.childNodes;
    for (var i = 0, l = c$.length, child; i < l && (child = c$[i]); i++) {
      s += getOuterHTML(child, node, composed);
    }
    return s;
  }

  /**
  @license
  Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */

  var nodeWalker = document.createTreeWalker(document, NodeFilter.SHOW_ALL, null, false);

  var elementWalker = document.createTreeWalker(document, NodeFilter.SHOW_ELEMENT, null, false);

  function parentNode(node) {
    nodeWalker.currentNode = node;
    return nodeWalker.parentNode();
  }

  function firstChild(node) {
    nodeWalker.currentNode = node;
    return nodeWalker.firstChild();
  }

  function lastChild(node) {
    nodeWalker.currentNode = node;
    return nodeWalker.lastChild();
  }

  function previousSibling(node) {
    nodeWalker.currentNode = node;
    return nodeWalker.previousSibling();
  }

  function nextSibling(node) {
    nodeWalker.currentNode = node;
    return nodeWalker.nextSibling();
  }

  function childNodes(node) {
    var nodes = [];
    nodeWalker.currentNode = node;
    var n = nodeWalker.firstChild();
    while (n) {
      nodes.push(n);
      n = nodeWalker.nextSibling();
    }
    return nodes;
  }

  function parentElement(node) {
    elementWalker.currentNode = node;
    return elementWalker.parentNode();
  }

  function firstElementChild(node) {
    elementWalker.currentNode = node;
    return elementWalker.firstChild();
  }

  function lastElementChild(node) {
    elementWalker.currentNode = node;
    return elementWalker.lastChild();
  }

  function previousElementSibling(node) {
    elementWalker.currentNode = node;
    return elementWalker.previousSibling();
  }

  function nextElementSibling(node) {
    elementWalker.currentNode = node;
    return elementWalker.nextSibling();
  }

  function children(node) {
    var nodes = [];
    elementWalker.currentNode = node;
    var n = elementWalker.firstChild();
    while (n) {
      nodes.push(n);
      n = elementWalker.nextSibling();
    }
    return nodes;
  }

  function innerHTML(node) {
    return getInnerHTML(node, function (n) {
      return childNodes(n);
    });
  }

  function textContent(node) {
    if (node.nodeType !== Node.ELEMENT_NODE) {
      return node.nodeValue;
    }
    var textWalker = document.createTreeWalker(node, NodeFilter.SHOW_TEXT, null, false);
    var content = '',
        n = void 0;
    while (n = textWalker.nextNode()) {
      // TODO(sorvell): can't use textContent since we patch it on Node.prototype!
      // However, should probably patch it only on element.
      content += n.nodeValue;
    }
    return content;
  }

  var nativeTree = Object.freeze({
    parentNode: parentNode,
    firstChild: firstChild,
    lastChild: lastChild,
    previousSibling: previousSibling,
    nextSibling: nextSibling,
    childNodes: childNodes,
    parentElement: parentElement,
    firstElementChild: firstElementChild,
    lastElementChild: lastElementChild,
    previousElementSibling: previousElementSibling,
    nextElementSibling: nextElementSibling,
    children: children,
    innerHTML: innerHTML,
    textContent: textContent
  });

  /**
  @license
  Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */

  function getProperty(node, prop) {
    return node.__shady && node.__shady[prop];
  }

  function hasProperty(node, prop) {
    return getProperty(node, prop) !== undefined;
  }

  function recordInsertBefore(node, container, ref_node) {
    container.__shady = container.__shady || {};
    if (hasProperty(container, 'firstChild')) {
      container.__shady.childNodes = null;
    }
    // handle document fragments
    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      var c$ = node.childNodes;
      for (var i = 0; i < c$.length; i++) {
        linkNode(c$[i], container, ref_node);
      }
      // cleanup logical dom in doc fragment.
      node.__shady = node.__shady || {};
      var resetTo = hasProperty(node, 'firstChild') ? null : undefined;
      node.__shady.firstChild = node.__shady.lastChild = resetTo;
      node.__shady.childNodes = resetTo;
    } else {
      linkNode(node, container, ref_node);
    }
  }

  function linkNode(node, container, ref_node) {
    ref_node = ref_node || null;
    node.__shady = node.__shady || {};
    container.__shady = container.__shady || {};
    if (ref_node) {
      ref_node.__shady = ref_node.__shady || {};
    }
    // update ref_node.previousSibling <-> node
    node.__shady.previousSibling = ref_node ? ref_node.__shady.previousSibling : container.lastChild;
    var ps = node.__shady.previousSibling;
    if (ps && ps.__shady) {
      ps.__shady.nextSibling = node;
    }
    // update node <-> ref_node
    var ns = node.__shady.nextSibling = ref_node;
    if (ns && ns.__shady) {
      ns.__shady.previousSibling = node;
    }
    // update node <-> container
    node.__shady.parentNode = container;
    if (ref_node) {
      if (ref_node === container.__shady.firstChild) {
        container.__shady.firstChild = node;
      }
    } else {
      container.__shady.lastChild = node;
      if (!container.__shady.firstChild) {
        container.__shady.firstChild = node;
      }
    }
    // remove caching of childNodes
    container.__shady.childNodes = null;
  }

  function recordRemoveChild(node, container) {
    node.__shady = node.__shady || {};
    container.__shady = container.__shady || {};
    if (node === container.__shady.firstChild) {
      container.__shady.firstChild = node.__shady.nextSibling;
    }
    if (node === container.__shady.lastChild) {
      container.__shady.lastChild = node.__shady.previousSibling;
    }
    var p = node.__shady.previousSibling;
    var n = node.__shady.nextSibling;
    if (p) {
      p.__shady = p.__shady || {};
      p.__shady.nextSibling = n;
    }
    if (n) {
      n.__shady = n.__shady || {};
      n.__shady.previousSibling = p;
    }
    // When an element is removed, logical data is no longer tracked.
    // Explicitly set `undefined` here to indicate this. This is disginguished
    // from `null` which is set if info is null.
    node.__shady.parentNode = node.__shady.previousSibling = node.__shady.nextSibling = undefined;
    if (hasProperty(container, 'childNodes')) {
      // remove caching of childNodes
      container.__shady.childNodes = null;
    }
  }

  var recordChildNodes = function recordChildNodes(node) {
    if (!hasProperty(node, 'firstChild')) {
      node.__shady = node.__shady || {};
      node.__shady.firstChild = firstChild(node);
      node.__shady.lastChild = lastChild(node);
      var c$ = node.__shady.childNodes = childNodes(node);
      for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {
        n.__shady = n.__shady || {};
        n.__shady.parentNode = node;
        n.__shady.nextSibling = c$[i + 1] || null;
        n.__shady.previousSibling = c$[i - 1] || null;
      }
    }
  };

  /**
  @license
  Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */

  var nativeAppendChild = Element.prototype.appendChild;
  var nativeInsertBefore = Element.prototype.insertBefore;
  var nativeRemoveChild = Element.prototype.removeChild;
  var nativeSetAttribute = Element.prototype.setAttribute;
  var nativeRemoveAttribute = Element.prototype.removeAttribute;
  var nativeCloneNode = Element.prototype.cloneNode;
  var nativeImportNode = Document.prototype.importNode;

  function appendChild(parent, child) {
    return nativeAppendChild.call(parent, child);
  }

  function insertBefore(parent, child, ref_node) {
    return nativeInsertBefore.call(parent, child, ref_node);
  }
  function removeChild(parent, child) {
    return nativeRemoveChild.call(parent, child);
  }

  function setAttribute(node, name, value) {
    nativeSetAttribute.call(node, name, value);
  }

  function removeAttribute(node, name) {
    nativeRemoveAttribute.call(node, name);
  }

  function cloneNode(node, deep) {
    return nativeCloneNode.call(node, deep);
  }

  function importNode(node, deep) {
    return nativeImportNode.call(document, node, deep);
  }

  var nativeMethods = Object.freeze({
    appendChild: appendChild,
    insertBefore: insertBefore,
    removeChild: removeChild,
    setAttribute: setAttribute,
    removeAttribute: removeAttribute,
    cloneNode: cloneNode,
    importNode: importNode
  });

  /**
  @license
  Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */

  // Try to add node. Record logical info, track insertion points, perform
  // distribution iff needed. Return true if the add is handled.
  function addNode(container, node, ref_node) {
    var ownerRoot = ownerShadyRootForNode(container);
    var ipAdded = void 0;
    if (ownerRoot) {
      // optimization: special insertion point tracking
      // TODO(sorvell): verify that the renderPending check here should not be needed.
      // if (node.__noInsertionPoint && !ownerRoot._renderPending) {
      if (node.__noInsertionPoint) {
        ownerRoot._skipUpdateInsertionPoints = true;
      }
      // note: we always need to see if an insertion point is added
      // since this saves logical tree info; however, invalidation state
      // needs
      ipAdded = _maybeAddInsertionPoint(node, container, ownerRoot);
      // invalidate insertion points IFF not already invalid!
      if (ipAdded) {
        ownerRoot._skipUpdateInsertionPoints = false;
      }
    }
    if (hasProperty(container, 'firstChild')) {
      recordInsertBefore(node, container, ref_node);
    }
    // if not distributing and not adding to host, do a fast path addition
    // TODO(sorvell): revisit flow since `ipAdded` needed here if
    // node is a fragment that has a patched QSA.
    var handled = _maybeDistribute(node, container, ownerRoot, ipAdded) || container.shadyRoot;
    return handled;
  }

  // Try to remove node: update logical info and perform distribution iff
  // needed. Return true if the removal has been handled.
  // note that it's possible for both the node's host and its parent
  // to require distribution... both cases are handled here.
  function removeNode(node) {
    // important that we want to do this only if the node has a logical parent
    var logicalParent = hasProperty(node, 'parentNode') && getProperty(node, 'parentNode');
    var distributed = void 0;
    var ownerRoot = ownerShadyRootForNode(node);
    if (logicalParent || ownerRoot) {
      // distribute node's parent iff needed
      distributed = maybeDistributeParent(node);
      if (logicalParent) {
        recordRemoveChild(node, logicalParent);
      }
      // remove node from root and distribute it iff needed
      var removedDistributed = ownerRoot && _removeDistributedChildren(ownerRoot, node);
      var addedInsertionPoint = logicalParent && ownerRoot && logicalParent.localName === ownerRoot.getInsertionPointTag();
      if (removedDistributed || addedInsertionPoint) {
        ownerRoot._skipUpdateInsertionPoints = false;
        ownerRoot.update();
      }
    }
    _removeOwnerShadyRoot(node);
    return distributed;
  }

  function _scheduleObserver(node, addedNode, removedNode) {
    var observer = node.__shady && node.__shady.observer;
    if (observer) {
      if (addedNode) {
        observer.addedNodes.push(addedNode);
      }
      if (removedNode) {
        observer.removedNodes.push(removedNode);
      }
      observer.schedule();
    }
  }

  function removeNodeFromParent(node, parent) {
    if (parent) {
      _scheduleObserver(parent, null, node);
      return removeNode(node);
    } else {
      _removeOwnerShadyRoot(node);
    }
  }

  function _hasCachedOwnerRoot(node) {
    return Boolean(node.__ownerShadyRoot !== undefined);
  }

  function getRootNode(node) {
    if (!node || !node.nodeType) {
      return;
    }
    var root = node.__ownerShadyRoot;
    if (root === undefined) {
      if (isShadyRoot(node)) {
        root = node;
      } else {
        var parent = node.parentNode;
        root = parent ? getRootNode(parent) : node;
      }
      // memo-ize result for performance but only memo-ize
      // result if node is in the document. This avoids a problem where a root
      // can be cached while an element is inside a fragment.
      // If this happens and we cache the result, the value can become stale
      // because for perf we avoid processing the subtree of added fragments.
      if (document.documentElement.contains(node)) {
        node.__ownerShadyRoot = root;
      }
    }
    return root;
  }

  function ownerShadyRootForNode(node) {
    var root = getRootNode(node);
    if (isShadyRoot(root)) {
      return root;
    }
  }

  function _maybeDistribute(node, container, ownerRoot, ipAdded) {
    // TODO(sorvell): technically we should check non-fragment nodes for
    // <content> children but since this case is assumed to be exceedingly
    // rare, we avoid the cost and will address with some specific api
    // when the need arises.  For now, the user must call
    // distributeContent(true), which updates insertion points manually
    // and forces distribution.
    var insertionPointTag = ownerRoot && ownerRoot.getInsertionPointTag() || '';
    var fragContent = node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !node.__noInsertionPoint && insertionPointTag && node.querySelector(insertionPointTag);
    var wrappedContent = fragContent && fragContent.parentNode.nodeType !== Node.DOCUMENT_FRAGMENT_NODE;
    var hasContent = fragContent || node.localName === insertionPointTag;
    // There are 3 possible cases where a distribution may need to occur:
    // 1. <content> being inserted (the host of the shady root where
    //    content is inserted needs distribution)
    // 2. children being inserted into parent with a shady root (parent
    //    needs distribution)
    // 3. container is an insertionPoint
    if (hasContent || container.localName === insertionPointTag || ipAdded) {
      if (ownerRoot) {
        // note, insertion point list update is handled after node
        // mutations are complete
        ownerRoot.update();
      }
    }
    var needsDist = _nodeNeedsDistribution(container);
    if (needsDist) {
      container.shadyRoot.update();
    }
    // Return true when distribution will fully handle the composition
    // Note that if a content was being inserted that was wrapped by a node,
    // and the parent does not need distribution, return false to allow
    // the nodes to be added directly, after which children may be
    // distributed and composed into the wrapping node(s)
    return needsDist || hasContent && !wrappedContent;
  }

  /* note: parent argument is required since node may have an out
  of date parent at this point; returns true if a <content> is being added */
  function _maybeAddInsertionPoint(node, parent, root) {
    var added = void 0;
    var insertionPointTag = root.getInsertionPointTag();
    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !node.__noInsertionPoint) {
      var c$ = node.querySelectorAll(insertionPointTag);
      for (var i = 0, n, np, na; i < c$.length && (n = c$[i]); i++) {
        np = n.parentNode;
        // don't allow node's parent to be fragment itself
        if (np === node) {
          np = parent;
        }
        na = _maybeAddInsertionPoint(n, np, root);
        added = added || na;
      }
    } else if (node.localName === insertionPointTag) {
      recordChildNodes(parent);
      recordChildNodes(node);
      added = true;
    }
    return added;
  }

  function _nodeNeedsDistribution(node) {
    return node && node.shadyRoot && node.shadyRoot.hasInsertionPoint();
  }

  function _removeDistributedChildren(root, container) {
    var hostNeedsDist = void 0;
    var ip$ = root._insertionPoints;
    for (var i = 0; i < ip$.length; i++) {
      var insertionPoint = ip$[i];
      if (_contains(container, insertionPoint)) {
        var dc$ = insertionPoint.assignedNodes({ flatten: true });
        for (var j = 0; j < dc$.length; j++) {
          hostNeedsDist = true;
          var node = dc$[j];
          var parent = parentNode(node);
          if (parent) {
            removeChild(parent, node);
          }
        }
      }
    }
    return hostNeedsDist;
  }

  function _contains(container, node) {
    while (node) {
      if (node == container) {
        return true;
      }
      node = node.parentNode;
    }
  }

  function _removeOwnerShadyRoot(node) {
    // optimization: only reset the tree if node is actually in a root
    if (_hasCachedOwnerRoot(node)) {
      var c$ = node.childNodes;
      for (var i = 0, l = c$.length, n; i < l && (n = c$[i]); i++) {
        _removeOwnerShadyRoot(n);
      }
    }
    node.__ownerShadyRoot = undefined;
  }

  // TODO(sorvell): This will fail if distribution that affects this
  // question is pending; this is expected to be exceedingly rare, but if
  // the issue comes up, we can force a flush in this case.
  function firstComposedNode(insertionPoint) {
    var n$ = insertionPoint.assignedNodes({ flatten: true });
    var root = getRootNode(insertionPoint);
    for (var i = 0, l = n$.length, n; i < l && (n = n$[i]); i++) {
      // means that we're composed to this spot.
      if (root.isFinalDestination(insertionPoint, n)) {
        return n;
      }
    }
  }

  function clearNode(node) {
    while (node.firstChild) {
      node.removeChild(node.firstChild);
    }
  }

  function maybeDistributeParent(node) {
    var parent = node.parentNode;
    if (_nodeNeedsDistribution(parent)) {
      parent.shadyRoot.update();
      return true;
    }
  }

  function distributeAttributeChange(node, name) {
    if (name === 'slot') {
      maybeDistributeParent(node);
    } else if (node.localName === 'slot' && name === 'name') {
      var root = ownerShadyRootForNode(node);
      if (root) {
        root.update();
      }
    }
  }

  // NOTE: `query` is used primarily for ShadyDOM's querySelector impl,
  // but it's also generally useful to recurse through the element tree
  // and is used by Polymer's styling system.
  function query(node, matcher, halter) {
    var list = [];
    _queryElements(node.childNodes, matcher, halter, list);
    return list;
  }

  function _queryElements(elements, matcher, halter, list) {
    for (var i = 0, l = elements.length, c; i < l && (c = elements[i]); i++) {
      if (c.nodeType === Node.ELEMENT_NODE && _queryElement(c, matcher, halter, list)) {
        return true;
      }
    }
  }

  function _queryElement(node, matcher, halter, list) {
    var result = matcher(node);
    if (result) {
      list.push(node);
    }
    if (halter && halter(result)) {
      return result;
    }
    _queryElements(node.childNodes, matcher, halter, list);
  }

  var nativeActiveElementDescriptor = Object.getOwnPropertyDescriptor(Document.prototype, 'activeElement');
  function getDocumentActiveElement() {
    if (nativeActiveElementDescriptor && nativeActiveElementDescriptor.get) {
      return nativeActiveElementDescriptor.get.call(document);
    }
  }

  function activeElementForNode(node) {
    var active = getDocumentActiveElement();
    if (!active) {
      return null;
    }
    var isShadyRoot$$1 = !!isShadyRoot(node);
    if (node !== document) {
      // If this node isn't a document or shady root, then it doesn't have
      // an active element.
      if (!isShadyRoot$$1) {
        return null;
      }
      // If this shady root's host is the active element or the active
      // element is not a descendant of the host (in the composed tree),
      // then it doesn't have an active element.
      if (node.host === active || !node.host.contains(active)) {
        return null;
      }
    }
    // This node is either the document or a shady root of which the active
    // element is a (composed) descendant of its host; iterate upwards to
    // find the active element's most shallow host within it.
    var activeRoot = ownerShadyRootForNode(active);
    while (activeRoot && activeRoot !== node) {
      active = activeRoot.host;
      activeRoot = ownerShadyRootForNode(active);
    }
    if (node === document) {
      // This node is the document, so activeRoot should be null.
      return activeRoot ? null : active;
    } else {
      // This node is a non-document shady root, and it should be
      // activeRoot.
      return activeRoot === node ? active : null;
    }
  }

  var activeElementDescriptor = {
    get: function get() {
      return activeElementForNode(this);
    }
  };

  function renderRootNode(element) {
    var root = element.getRootNode();
    if (isShadyRoot(root)) {
      root.render();
    }
  }

  function setAttribute$1(node, attr, value) {
    // avoid scoping elements in non-main document to avoid template documents
    if (window.ShadyCSS && attr === 'class' && node.ownerDocument === document) {
      window.ShadyCSS.setElementClass(node, value);
    } else {
      setAttribute(node, attr, value);
      distributeAttributeChange(node, attr);
    }
  }

  function removeAttribute$1(node, attr) {
    removeAttribute(node, attr);
    distributeAttributeChange(node, name);
  }

  // cases in which we may not be able to just do standard native call
  // 1. container has a shadyRoot (needsDistribution IFF the shadyRoot
  // has an insertion point)
  // 2. container is a shadyRoot (don't distribute, instead set
  // container to container.host.
  // 3. node is <content> (host of container needs distribution)
  function insertBefore$1(parent, node, ref_node) {
    if (ref_node) {
      var _p = getProperty(ref_node, 'parentNode');
      if (_p !== undefined && _p !== parent) {
        throw Error('The ref_node to be inserted before is not a child ' + 'of this node');
      }
    }
    // remove node from its current position iff it's in a tree.
    if (node.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
      var _parent = getProperty(node, 'parentNode');
      removeNodeFromParent(node, _parent);
    }
    if (!addNode(parent, node, ref_node)) {
      if (ref_node) {
        // if ref_node is an insertion point replace with first distributed node
        var root = ownerShadyRootForNode(ref_node);
        if (root) {
          ref_node = ref_node.localName === root.getInsertionPointTag() ? firstComposedNode(ref_node) : ref_node;
        }
      }
      // if adding to a shadyRoot, add to host instead
      var container = isShadyRoot(parent) ? parent.host : parent;
      if (ref_node) {
        insertBefore(container, node, ref_node);
      } else {
        appendChild(container, node);
      }
    }
    _scheduleObserver(parent, node);
    return node;
  }

  /**
    Removes the given `node` from the element's `lightChildren`.
    This method also performs dom composition.
  */
  function removeChild$1(parent, node) {
    if (node.parentNode !== parent) {
      throw Error('The node to be removed is not a child of this node: ' + node);
    }
    if (!removeNode(node)) {
      // if removing from a shadyRoot, remove form host instead
      var container = isShadyRoot(parent) ? parent.host : parent;
      // not guaranteed to physically be in container; e.g.
      // undistributed nodes.
      var nativeParent = parentNode(node);
      if (container === nativeParent) {
        removeChild(container, node);
      }
    }
    _scheduleObserver(parent, null, node);
    return node;
  }

  function cloneNode$1(node, deep) {
    if (node.localName == 'template') {
      return cloneNode(node, deep);
    } else {
      var n = cloneNode(node, false);
      if (deep) {
        var c$ = node.childNodes;
        for (var i = 0, nc; i < c$.length; i++) {
          nc = c$[i].cloneNode(true);
          n.appendChild(nc);
        }
      }
      return n;
    }
  }

  /**
  @license
  Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */

  function generateSimpleDescriptor(prop) {
    return {
      get: function get() {
        var l = getProperty(this, prop);
        return l !== undefined ? l : nativeTree[prop](this);
      },

      configurable: true
    };
  }

  var assignedSlotDesc = {
    get: function get() {
      return getProperty(this, 'assignedSlot') || null;
    },

    configurable: true
  };

  var NodeMixin = {
    appendChild: function appendChild(node) {
      return insertBefore$1(this, node);
    },
    insertBefore: function insertBefore(node, ref_node) {
      return insertBefore$1(this, node, ref_node);
    },


    /**
      Removes the given `node` from the element's `lightChildren`.
      This method also performs dom composition.
    */
    removeChild: function removeChild(node) {
      return removeChild$1(this, node);
    },
    replaceChild: function replaceChild(node, ref_node) {
      this.insertBefore(node, ref_node);
      this.removeChild(ref_node);
      return node;
    },
    cloneNode: function cloneNode(deep) {
      return cloneNode$1(this, deep);
    }
  };

  Object.defineProperties(NodeMixin, {

    parentElement: generateSimpleDescriptor('parentElement'),

    parentNode: generateSimpleDescriptor('parentNode'),

    nextSibling: generateSimpleDescriptor('nextSibling'),

    previousSibling: generateSimpleDescriptor('previousSibling'),

    childNodes: {
      get: function get() {
        if (hasProperty(this, 'firstChild')) {
          if (!this.__shady.childNodes) {
            this.__shady.childNodes = [];
            for (var n = this.firstChild; n; n = n.nextSibling) {
              this.__shady.childNodes.push(n);
            }
          }
          return this.__shady.childNodes;
        } else {
          return childNodes(this);
        }
      },

      configurable: true
    },

    firstChild: generateSimpleDescriptor('firstChild'),

    lastChild: generateSimpleDescriptor('lastChild'),

    textContent: {
      get: function get() {
        if (hasProperty(this, 'firstChild')) {
          var tc = [];
          for (var i = 0, cn = this.childNodes, c; c = cn[i]; i++) {
            if (c.nodeType !== Node.COMMENT_NODE) {
              tc.push(c.textContent);
            }
          }
          return tc.join('');
        } else {
          return textContent(this);
        }
      },
      set: function set(text) {
        if (this.nodeType !== Node.ELEMENT_NODE) {
          // TODO(sorvell): can't do this if patch nodeValue.
          this.nodeValue = text;
        } else {
          clearNode(this);
          if (text) {
            this.appendChild(document.createTextNode(text));
          }
        }
      },

      configurable: true
    }
  });

  // NOTE: For some reason `Text` redefines `assignedSlot`
  var TextMixin = extend({}, NodeMixin);
  Object.defineProperties(TextMixin, {
    assignedSlot: assignedSlotDesc
  });

  var FragmentMixin = {

    // TODO(sorvell): consider doing native QSA and filtering results.
    querySelector: function querySelector(selector) {
      // match selector and halt on first result.
      var result = query(this, function (n) {
        return matchesSelector(n, selector);
      }, function (n) {
        return Boolean(n);
      })[0];
      return result || null;
    },
    querySelectorAll: function querySelectorAll(selector) {
      return query(this, function (n) {
        return matchesSelector(n, selector);
      });
    }
  };

  var childrenDescriptor = {
    get: function get() {
      if (hasProperty(this, 'firstChild')) {
        return Array.prototype.filter.call(this.childNodes, function (n) {
          return n.nodeType === Node.ELEMENT_NODE;
        });
      } else {
        return children(this);
      }
    },

    configurable: true
  };

  var domParser = new DOMParser();

  var insertDOMFrom = function insertDOMFrom(target, from) {
    var c$ = Array.from(from.childNodes);
    for (var i = 0; i < c$.length; i++) {
      target.appendChild(c$[i]);
    }
  };

  var innerHTMLDescriptor = {
    get: function get() {
      if (hasProperty(this, 'firstChild')) {
        return getInnerHTML(this);
      } else {
        return innerHTML(this);
      }
    },
    set: function set(text) {
      clearNode(this);
      var doc = domParser.parseFromString(text, 'text/html');
      if (doc.head) {
        insertDOMFrom(this, doc.head);
      }
      if (doc.body) {
        insertDOMFrom(this, doc.body);
      }
    },

    configurable: true
  };

  Object.defineProperties(FragmentMixin, {

    children: childrenDescriptor,

    innerHTML: innerHTMLDescriptor,

    firstElementChild: {
      get: function get() {
        if (hasProperty(this, 'firstChild')) {
          var n = this.firstChild;
          while (n && n.nodeType !== Node.ELEMENT_NODE) {
            n = n.nextSibling;
          }
          return n;
        } else {
          return firstElementChild(this);
        }
      },

      configurable: true
    },

    lastElementChild: {
      get: function get() {
        if (hasProperty(this, 'lastChild')) {
          var n = this.lastChild;
          while (n && n.nodeType !== Node.ELEMENT_NODE) {
            n = n.previousSibling;
          }
          return n;
        } else {
          return lastElementChild(this);
        }
      },

      configurable: true
    }

  });

  var SlotMixin = {
    assignedNodes: function assignedNodes(options) {
      if (this.localName === 'slot') {
        renderRootNode(this);
        return this.__shady ? (options && options.flatten ? this.__shady.distributedNodes : this.__shady.assignedNodes) || [] : [];
      }
    }
  };

  var ElementMixin = extendAll({}, FragmentMixin, SlotMixin, {
    setAttribute: function setAttribute(name, value) {
      setAttribute$1(this, name, value);
    },
    removeAttribute: function removeAttribute(name) {
      removeAttribute$1(this, name);
    }
  });

  Object.defineProperties(ElementMixin, {

    assignedSlot: assignedSlotDesc,

    shadowRoot: {
      get: function get() {
        return this.shadyRoot;
      },
      set: function set(value) {
        this.shadyRoot = value;
      },

      configurable: true
    },

    nextElementSibling: {
      get: function get() {
        if (hasProperty(this, 'nextSibling')) {
          var n = this.nextSibling;
          while (n && n.nodeType !== Node.ELEMENT_NODE) {
            n = n.nextSibling;
          }
          return n;
        } else {
          return nextElementSibling(this);
        }
      },

      configurable: true
    },

    previousElementSibling: {
      get: function get() {
        if (hasProperty(this, 'previousSibling')) {
          var n = this.previousSibling;
          while (n && n.nodeType !== Node.ELEMENT_NODE) {
            n = n.previousSibling;
          }
          return n;
        } else {
          return previousElementSibling(this);
        }
      },

      configurable: true
    },

    slot: {
      get: function get() {
        return this.getAttribute('slot');
      },
      set: function set(value) {
        this.setAttribute('slot', value);
      }
    }

  });

  var HTMLElementMixin = {};

  Object.defineProperties(HTMLElementMixin, {

    children: childrenDescriptor,

    innerHTML: innerHTMLDescriptor

  });

  var ActiveElementMixin = {};
  Object.defineProperties(ActiveElementMixin, {
    activeElement: activeElementDescriptor
  });

  var UnderActiveElementMixin = {};
  Object.defineProperties(UnderActiveElementMixin, {
    _activeElement: activeElementDescriptor
  });

  var Mixins = {

    Node: NodeMixin,

    Fragment: FragmentMixin,

    Text: TextMixin,

    Slot: SlotMixin,

    Element: ElementMixin,

    HTMLElement: HTMLElementMixin,

    // Note: activeElement cannot be patched on document (on some browsers)
    Document: extendAll({}, ElementMixin, UnderActiveElementMixin, ActiveElementMixin)
  };

  var patchProto = function patchProto(proto, mixin$$1, ifExists) {
    proto.__nativeProps = Object.create(proto.__nativeProps || {});
    var n$ = Object.getOwnPropertyNames(mixin$$1);
    for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
      var sd = Object.getOwnPropertyDescriptor(proto, n);
      if (sd) {
        if (!sd.configurable) {
          window.console.warn('Could not patch', n, 'on', proto);
          return;
        }
        proto.__nativeProps[n] = sd;
      }
      if (!ifExists || sd && sd.configurable) {
        var md = Object.getOwnPropertyDescriptor(mixin$$1, n);
        Object.defineProperty(proto, n, md);
      }
    }
  };

  var getComposedInnerHTML = function getComposedInnerHTML(node) {
    return getInnerHTML(node, function (n) {
      return childNodes(n);
    });
  };

  var getComposedChildNodes = function getComposedChildNodes(node) {
    return childNodes(node);
  };

  /**
  @license
  Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */

  // NOTE: normalize event contruction where necessary (IE11)
  var NormalizedEvent = typeof Event === 'function' ? Event : function (inType, params) {
    params = params || {};
    var e = document.createEvent('Event');
    e.initEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable));
    return e;
  };

  var Distributor = function () {
    function Distributor(root) {
      _classCallCheck(this, Distributor);

      this.root = root;
      this.insertionPointTag = 'slot';
    }

    _createClass(Distributor, [{
      key: 'getInsertionPoints',
      value: function getInsertionPoints() {
        return this.root.querySelectorAll(this.insertionPointTag);
      }
    }, {
      key: 'hasInsertionPoint',
      value: function hasInsertionPoint() {
        return Boolean(this.root._insertionPoints && this.root._insertionPoints.length);
      }
    }, {
      key: 'isInsertionPoint',
      value: function isInsertionPoint(node) {
        return node.localName && node.localName == this.insertionPointTag;
      }
    }, {
      key: 'distribute',
      value: function distribute() {
        if (this.hasInsertionPoint()) {
          return this.distributePool(this.root, this.collectPool());
        }
        return [];
      }

      // Gather the pool of nodes that should be distributed. We will combine
      // these with the "content root" to arrive at the composed tree.

    }, {
      key: 'collectPool',
      value: function collectPool() {
        var host = this.root.host;
        var pool = [],
            i = 0;
        for (var n = host.firstChild; n; n = n.nextSibling) {
          pool[i++] = n;
        }
        return pool;
      }

      // perform "logical" distribution; note, no actual dom is moved here,
      // instead elements are distributed into storage
      // array where applicable.

    }, {
      key: 'distributePool',
      value: function distributePool(node, pool) {
        var dirtyRoots = [];
        var p$ = this.root._insertionPoints;
        for (var i = 0, l = p$.length, _p2; i < l && (_p2 = p$[i]); i++) {
          this.distributeInsertionPoint(_p2, pool);
          // provoke redistribution on insertion point parents
          // must do this on all candidate hosts since distribution in this
          // scope invalidates their distribution.
          // only get logical parent.
          var parent = _p2.parentNode;
          if (parent && parent.shadyRoot && this.hasInsertionPoint(parent.shadyRoot)) {
            dirtyRoots.push(parent.shadyRoot);
          }
        }
        for (var _i2 = 0; _i2 < pool.length; _i2++) {
          var _p3 = pool[_i2];
          if (_p3) {
            _p3.__shady = _p3.__shady || {};
            _p3.__shady.assignedSlot = undefined;
            // remove undistributed elements from physical dom.
            var _parent2 = parentNode(_p3);
            if (_parent2) {
              removeChild(_parent2, _p3);
            }
          }
        }
        return dirtyRoots;
      }
    }, {
      key: 'distributeInsertionPoint',
      value: function distributeInsertionPoint(insertionPoint, pool) {
        var prevAssignedNodes = insertionPoint.__shady.assignedNodes;
        if (prevAssignedNodes) {
          this.clearAssignedSlots(insertionPoint, true);
        }
        insertionPoint.__shady.assignedNodes = [];
        var needsSlotChange = false;
        // distribute nodes from the pool that this selector matches
        var anyDistributed = false;
        for (var i = 0, l = pool.length, node; i < l; i++) {
          node = pool[i];
          // skip nodes that were already used
          if (!node) {
            continue;
          }
          // distribute this node if it matches
          if (this.matchesInsertionPoint(node, insertionPoint)) {
            if (node.__shady._prevAssignedSlot != insertionPoint) {
              needsSlotChange = true;
            }
            this.distributeNodeInto(node, insertionPoint);
            // remove this node from the pool
            pool[i] = undefined;
            // since at least one node matched, we won't need fallback content
            anyDistributed = true;
          }
        }
        // Fallback content if nothing was distributed here
        if (!anyDistributed) {
          var children$$1 = insertionPoint.childNodes;
          for (var j = 0, _node; j < children$$1.length; j++) {
            _node = children$$1[j];
            if (_node.__shady._prevAssignedSlot != insertionPoint) {
              needsSlotChange = true;
            }
            this.distributeNodeInto(_node, insertionPoint);
          }
        }
        // we're already dirty if a node was newly added to the slot
        // and we're also dirty if the assigned count decreased.
        if (prevAssignedNodes) {
          // TODO(sorvell): the tracking of previously assigned slots
          // could instead by done with a Set and then we could
          // avoid needing to iterate here to clear the info.
          for (var _i3 = 0; _i3 < prevAssignedNodes.length; _i3++) {
            prevAssignedNodes[_i3].__shady._prevAssignedSlot = null;
          }
          if (insertionPoint.__shady.assignedNodes.length < prevAssignedNodes.length) {
            needsSlotChange = true;
          }
        }
        this.setDistributedNodesOnInsertionPoint(insertionPoint);
        if (needsSlotChange) {
          this._fireSlotChange(insertionPoint);
        }
      }
    }, {
      key: 'clearAssignedSlots',
      value: function clearAssignedSlots(slot, savePrevious) {
        var n$ = slot.__shady.assignedNodes;
        if (n$) {
          for (var i = 0; i < n$.length; i++) {
            var n = n$[i];
            if (savePrevious) {
              n.__shady._prevAssignedSlot = n.__shady.assignedSlot;
            }
            // only clear if it was previously set to this slot;
            // this helps ensure that if the node has otherwise been distributed
            // ignore it.
            if (n.__shady.assignedSlot === slot) {
              n.__shady.assignedSlot = null;
            }
          }
        }
      }
    }, {
      key: 'matchesInsertionPoint',
      value: function matchesInsertionPoint(node, insertionPoint) {
        var slotName = insertionPoint.getAttribute('name');
        slotName = slotName ? slotName.trim() : '';
        var slot = node.getAttribute && node.getAttribute('slot');
        slot = slot ? slot.trim() : '';
        return slot == slotName;
      }
    }, {
      key: 'distributeNodeInto',
      value: function distributeNodeInto(child, insertionPoint) {
        insertionPoint.__shady.assignedNodes.push(child);
        child.__shady.assignedSlot = insertionPoint;
      }
    }, {
      key: 'setDistributedNodesOnInsertionPoint',
      value: function setDistributedNodesOnInsertionPoint(insertionPoint) {
        var n$ = insertionPoint.__shady.assignedNodes;
        insertionPoint.__shady.distributedNodes = [];
        for (var i = 0, n; i < n$.length && (n = n$[i]); i++) {
          if (this.isInsertionPoint(n)) {
            var d$ = n.__shady.distributedNodes;
            if (d$) {
              for (var j = 0; j < d$.length; j++) {
                insertionPoint.__shady.distributedNodes.push(d$[j]);
              }
            }
          } else {
            insertionPoint.__shady.distributedNodes.push(n$[i]);
          }
        }
      }
    }, {
      key: '_fireSlotChange',
      value: function _fireSlotChange(insertionPoint) {
        // NOTE: cannot bubble correctly here so not setting bubbles: true
        // Safari tech preview does not bubble but chrome does
        // Spec says it bubbles (https://dom.spec.whatwg.org/#mutation-observers)
        insertionPoint.dispatchEvent(new NormalizedEvent('slotchange'));
        if (insertionPoint.__shady.assignedSlot) {
          this._fireSlotChange(insertionPoint.__shady.assignedSlot);
        }
      }
    }, {
      key: 'isFinalDestination',
      value: function isFinalDestination(insertionPoint) {
        return !insertionPoint.__shady.assignedSlot;
      }
    }]);

    return Distributor;
  }();

  /**
  @license
  Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */

  /**
    Implements a pared down version of ShadowDOM's scoping, which is easy to
    polyfill across browsers.
  */

  var ShadyRoot = function ShadyRoot(host) {
    _classCallCheck(this, ShadyRoot);

    if (!host) {
      throw 'Must provide a host';
    }
    // NOTE: this strange construction is necessary because
    // DocumentFragment cannot be subclassed on older browsers.
    var frag = document.createDocumentFragment();
    frag.__proto__ = ShadyFragmentMixin;
    frag._init(host);
    return frag;
  };

  var ShadyMixin = {
    _init: function _init(host) {
      // NOTE: set a fake local name so this element can be
      // distinguished from a DocumentFragment when patching.
      // FF doesn't allow this to be `localName`
      this.__localName = 'ShadyRoot';
      // root <=> host
      host.shadowRoot = this;
      this.host = host;
      // logical dom setup
      recordChildNodes(host);
      recordChildNodes(this);
      // state flags
      this._renderPending = false;
      this._hasRendered = false;
      this._distributor = new Distributor(this);
      this.update();
    },


    // async render
    update: function update() {
      var _this = this;

      if (!this._renderPending) {
        this._renderPending = true;
        enqueue(function () {
          return _this.render();
        });
      }
    },
    _getRenderRoot: function _getRenderRoot() {
      var root = this._rendererForHost();
      // TODO(sorvell): actually want the highest dirty root in distribution tree
      return root ? root._getRenderRoot() : this;
    },


    // Returns the shadyRoot `this.host` if `this.host`
    // has children that require distribution.
    _rendererForHost: function _rendererForHost() {
      var root = this.host.getRootNode();
      if (isShadyRoot(root)) {
        var c$ = this.host.childNodes;
        for (var i = 0, c; i < c$.length; i++) {
          c = c$[i];
          if (this._distributor.isInsertionPoint(c)) {
            return root;
          }
        }
      }
    },
    render: function render() {
      if (this._renderPending) {
        this._getRenderRoot()._render();
      }
    },
    _render: function _render() {
      this._renderPending = false;
      if (!this._skipUpdateInsertionPoints) {
        this.updateInsertionPoints();
      } else if (!this._hasRendered) {
        this._insertionPoints = [];
      }
      this._skipUpdateInsertionPoints = false;
      // TODO(sorvell): can add a first render optimization here
      // to use if there are no insertion points
      // 1. clear host node of composed children
      // 2. appendChild the shadowRoot itself or (more robust) its logical children
      // NOTE: this didn't seem worth it in perf testing
      // but not ready to delete this info.
      // logical
      this.distribute();
      // physical
      this.compose();
      this._hasRendered = true;
    },
    forceRender: function forceRender() {
      this._renderPending = true;
      this.render();
    },
    distribute: function distribute() {
      var dirtyRoots = this._distributor.distribute();
      for (var i = 0; i < dirtyRoots.length; i++) {
        dirtyRoots[i]._render();
      }
    },
    updateInsertionPoints: function updateInsertionPoints() {
      var i$ = this.__insertionPoints;
      // if any insertion points have been removed, clear their distribution info
      if (i$) {
        for (var i = 0, c; i < i$.length; i++) {
          c = i$[i];
          if (c.getRootNode() !== this) {
            this._distributor.clearAssignedSlots(c);
          }
        }
      }
      i$ = this._insertionPoints = this._distributor.getInsertionPoints();
      // ensure insertionPoints's and their parents have logical dom info.
      // save logical tree info
      // a. for shadyRoot
      // b. for insertion points (fallback)
      // c. for parents of insertion points
      for (var _i4 = 0, _c; _i4 < i$.length; _i4++) {
        _c = i$[_i4];
        _c.__shady = _c.__shady || {};
        recordChildNodes(_c);
        recordChildNodes(_c.parentNode);
      }
    },


    get _insertionPoints() {
      if (!this.__insertionPoints) {
        this.updateInsertionPoints();
      }
      return this.__insertionPoints || (this.__insertionPoints = []);
    },

    set _insertionPoints(insertionPoints) {
      this.__insertionPoints = insertionPoints;
    },

    hasInsertionPoint: function hasInsertionPoint() {
      return this._distributor.hasInsertionPoint();
    },
    compose: function compose() {
      // compose self
      // note: it's important to mark this clean before distribution
      // so that attachment that provokes additional distribution (e.g.
      // adding something to your parentNode) works
      this._composeTree();
      // TODO(sorvell): See fast paths here in Polymer v1
      // (these seem unnecessary)
    },


    // Reify dom such that it is at its correct rendering position
    // based on logical distribution.
    _composeTree: function _composeTree() {
      this._updateChildNodes(this.host, this._composeNode(this.host));
      var p$ = this._insertionPoints || [];
      for (var i = 0, l = p$.length, _p4, parent; i < l && (_p4 = p$[i]); i++) {
        parent = _p4.parentNode;
        if (parent !== this.host && parent !== this) {
          this._updateChildNodes(parent, this._composeNode(parent));
        }
      }
    },


    // Returns the list of nodes which should be rendered inside `node`.
    _composeNode: function _composeNode(node) {
      var children$$1 = [];
      var c$ = (node.shadyRoot || node).childNodes;
      for (var i = 0; i < c$.length; i++) {
        var child = c$[i];
        if (this._distributor.isInsertionPoint(child)) {
          var distributedNodes = child.__shady.distributedNodes || (child.__shady.distributedNodes = []);
          for (var j = 0; j < distributedNodes.length; j++) {
            var distributedNode = distributedNodes[j];
            if (this.isFinalDestination(child, distributedNode)) {
              children$$1.push(distributedNode);
            }
          }
        } else {
          children$$1.push(child);
        }
      }
      return children$$1;
    },
    isFinalDestination: function isFinalDestination(insertionPoint, node) {
      return this._distributor.isFinalDestination(insertionPoint, node);
    },


    // Ensures that the rendered node list inside `container` is `children`.
    _updateChildNodes: function _updateChildNodes(container, children$$1) {
      var composed = Array.from(isShadyRoot(container) ? container.childNodes : childNodes(container));
      var splices = calculateSplices(children$$1, composed);
      // process removals
      for (var i = 0, d = 0, s; i < splices.length && (s = splices[i]); i++) {
        for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {
          // check if the node is still where we expect it is before trying
          // to remove it; this can happen if we move a node and
          // then schedule its previous host for distribution resulting in
          // the node being removed here.
          if (parentNode(n) === container) {
            removeChild(container, n);
          }
          composed.splice(s.index + d, 1);
        }
        d -= s.addedCount;
      }
      // process adds
      for (var _i5 = 0, _s, next; _i5 < splices.length && (_s = splices[_i5]); _i5++) {
        //eslint-disable-line no-redeclare
        next = composed[_s.index];
        for (var _j2 = _s.index, _n; _j2 < _s.index + _s.addedCount; _j2++) {
          _n = children$$1[_j2];
          insertBefore(container, _n, next);
          // TODO(sorvell): is this splice strictly needed?
          composed.splice(_j2, 0, _n);
        }
      }
    },
    getInsertionPointTag: function getInsertionPointTag() {
      return this._distributor.insertionPointTag;
    }
  };

  var ShadyFragmentMixin = Object.create(DocumentFragment.prototype);
  extendAll(ShadyFragmentMixin, ShadyMixin, Mixins.Fragment);
  Object.defineProperty(ShadyFragmentMixin, 'activeElement', activeElementDescriptor);

  /**
  @license
  Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */

  var AsyncObserver = function () {
    function AsyncObserver() {
      _classCallCheck(this, AsyncObserver);

      this._scheduled = false;
      this.addedNodes = [];
      this.removedNodes = [];
      this.callbacks = new Set();
    }

    _createClass(AsyncObserver, [{
      key: 'schedule',
      value: function schedule() {
        var _this2 = this;

        if (!this._scheduled) {
          this._scheduled = true;
          promish.then(function () {
            _this2.flush();
          });
        }
      }
    }, {
      key: 'flush',
      value: function flush() {
        var _this3 = this;

        if (this._scheduled) {
          (function () {
            _this3._scheduled = false;
            var mutations = _this3.takeRecords();
            if (mutations.length) {
              _this3.callbacks.forEach(function (cb) {
                cb(mutations);
              });
            }
          })();
        }
      }
    }, {
      key: 'takeRecords',
      value: function takeRecords() {
        if (this.addedNodes.length || this.removedNodes.length) {
          var mutations = [{
            addedNodes: this.addedNodes,
            removedNodes: this.removedNodes
          }];
          this.addedNodes = [];
          this.removedNodes = [];
          return mutations;
        }
        return [];
      }
    }]);

    return AsyncObserver;
  }();

  // TODO(sorvell): consider instead polyfilling MutationObserver
  // directly so that users do not have to fork their code.
  // Supporting the entire api may be challenging: e.g. filtering out
  // removed nodes in the wrong scope and seeing non-distributing
  // subtree child mutations.


  var observeChildren = function observeChildren(node, callback) {
    //utils.common.patchNode(node);
    if (!node.__shady.observer) {
      node.__shady.observer = new AsyncObserver();
    }
    node.__shady.observer.callbacks.add(callback);
    var observer = node.__shady.observer;
    return {
      _callback: callback,
      _observer: observer,
      _node: node,
      takeRecords: function takeRecords() {
        return observer.takeRecords();
      }
    };
  };

  var unobserveChildren = function unobserveChildren(handle) {
    var observer = handle && handle._observer;
    if (observer) {
      observer.callbacks.delete(handle._callback);
      if (!observer.callbacks.size) {
        handle._node.__shady.observer = null;
      }
    }
  };

  function filterMutations(mutations, target) {
    var targetRootNode = target.getRootNode();
    return mutations.map(function (mutation) {
      var mutationInScope = targetRootNode === mutation.target.getRootNode();
      if (mutationInScope && mutation.addedNodes) {
        var nodes = Array.from(mutation.addedNodes).filter(function (n) {
          return targetRootNode === n.getRootNode();
        });
        if (nodes.length) {
          mutation = Object.create(mutation);
          Object.defineProperty(mutation, 'addedNodes', {
            value: nodes,
            configurable: true
          });
          return mutation;
        }
      } else if (mutationInScope) {
        return mutation;
      }
    }).filter(function (m) {
      return m;
    });
  }

  /**
  @license
  Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */

  var origAddEventListener = Element.prototype.addEventListener;
  var origRemoveEventListener = Element.prototype.removeEventListener;

  // https://github.com/w3c/webcomponents/issues/513#issuecomment-224183937
  var alwaysComposed = {
    blur: true,
    focus: true,
    focusin: true,
    focusout: true,
    click: true,
    dblclick: true,
    mousedown: true,
    mouseenter: true,
    mouseleave: true,
    mousemove: true,
    mouseout: true,
    mouseover: true,
    mouseup: true,
    wheel: true,
    beforeinput: true,
    input: true,
    keydown: true,
    keyup: true,
    compositionstart: true,
    compositionupdate: true,
    compositionend: true,
    touchstart: true,
    touchend: true,
    touchmove: true,
    touchcancel: true,
    pointerover: true,
    pointerenter: true,
    pointerdown: true,
    pointermove: true,
    pointerup: true,
    pointercancel: true,
    pointerout: true,
    pointerleave: true,
    gotpointercapture: true,
    lostpointercapture: true,
    dragstart: true,
    drag: true,
    dragenter: true,
    dragleave: true,
    dragover: true,
    drop: true,
    dragend: true,
    DOMActivate: true,
    DOMFocusIn: true,
    DOMFocusOut: true,
    keypress: true
  };

  function pathComposer(startNode, composed) {
    var composedPath = [];
    var current = startNode;
    var startRoot = startNode === window ? window : startNode.getRootNode();
    while (current) {
      composedPath.push(current);
      if (current.assignedSlot) {
        current = current.assignedSlot;
      } else if (current.nodeType === Node.DOCUMENT_FRAGMENT_NODE && current.host && (composed || current !== startRoot)) {
        current = current.host;
      } else {
        current = current.parentNode;
      }
    }
    // event composedPath includes window when startNode's ownerRoot is document
    if (composedPath[composedPath.length - 1] === document) {
      composedPath.push(window);
    }
    return composedPath;
  }

  function retarget(refNode, path) {
    if (!isShadyRoot) {
      return refNode;
    }
    // If ANCESTOR's root is not a shadow root or ANCESTOR's root is BASE's
    // shadow-including inclusive ancestor, return ANCESTOR.
    var refNodePath = pathComposer(refNode, true);
    var p$ = path;
    for (var i = 0, ancestor, lastRoot, root, rootIdx; i < p$.length; i++) {
      ancestor = p$[i];
      root = ancestor === window ? window : ancestor.getRootNode();
      if (root !== lastRoot) {
        rootIdx = refNodePath.indexOf(root);
        lastRoot = root;
      }
      if (!isShadyRoot(root) || rootIdx > -1) {
        return ancestor;
      }
    }
  }

  var EventMixin = {

    __patched: 5,

    get composed() {
      if (this.isTrusted && this.__composed === undefined) {
        this.__composed = alwaysComposed[this.type];
      }
      return this.__composed || false;
    },

    composedPath: function composedPath() {
      if (!this.__composedPath) {
        this.__composedPath = pathComposer(this.__target, this.composed);
      }
      return this.__composedPath;
    },


    get target() {
      return retarget(this.currentTarget, this.composedPath());
    },

    // http://w3c.github.io/webcomponents/spec/shadow/#event-relatedtarget-retargeting
    get relatedTarget() {
      if (!this.__relatedTarget) {
        return null;
      }
      if (!this.__relatedTargetComposedPath) {
        this.__relatedTargetComposedPath = pathComposer(this.__relatedTarget, true);
      }
      // find the deepest node in relatedTarget composed path that is in the same root with the currentTarget
      return retarget(this.currentTarget, this.__relatedTargetComposedPath);
    },
    stopPropagation: function stopPropagation() {
      Event.prototype.stopPropagation.call(this);
      this.__propagationStopped = true;
    },
    stopImmediatePropagation: function stopImmediatePropagation() {
      Event.prototype.stopImmediatePropagation.call(this);
      this.__immediatePropagationStopped = true;
      this.__propagationStopped = true;
    }
  };

  function mixinComposedFlag(Base) {
    // NOTE: avoiding use of `class` here so that transpiled output does not
    // try to do `Base.call` with a dom construtor.
    var klazz = function klazz(type, options) {
      var event = new Base(type, options);
      event.__composed = options && Boolean(options.composed);
      return event;
    };
    // put constructor properties on subclass
    mixin(klazz, Base);
    klazz.prototype = Base.prototype;
    return klazz;
  }

  var nonBubblingEventsToRetarget = {
    focus: true,
    blur: true
  };

  function fireHandlers(event, node, phase) {
    var hs = node.__handlers && node.__handlers[event.type] && node.__handlers[event.type][phase];
    if (hs) {
      for (var i = 0, fn; fn = hs[i]; i++) {
        fn.call(node, event);
        if (event.__immediatePropagationStopped) {
          return;
        }
      }
    }
  }

  function retargetNonBubblingEvent(e) {
    var path = e.composedPath();
    var node = void 0;
    // override `currentTarget` to let patched `target` calculate correctly
    Object.defineProperty(e, 'currentTarget', {
      get: function get() {
        return node;
      },
      configurable: true
    });
    for (var i = path.length - 1; i >= 0; i--) {
      node = path[i];
      // capture phase fires all capture handlers
      fireHandlers(e, node, 'capture');
      if (e.__propagationStopped) {
        return;
      }
    }

    // set the event phase to `AT_TARGET` as in spec
    Object.defineProperty(e, 'eventPhase', { value: Event.AT_TARGET });

    // the event only needs to be fired when owner roots change when iterating the event path
    // keep track of the last seen owner root
    var lastFiredRoot = void 0;
    for (var _i6 = 0; _i6 < path.length; _i6++) {
      node = path[_i6];
      if (_i6 === 0 || node.shadowRoot && node.shadowRoot === lastFiredRoot) {
        fireHandlers(e, node, 'bubble');
        // don't bother with window, it doesn't have `getRootNode` and will be last in the path anyway
        if (node !== window) {
          lastFiredRoot = node.getRootNode();
        }
        if (e.__propagationStopped) {
          return;
        }
      }
    }
  }

  function addEventListener(type, fn, optionsOrCapture) {
    if (!fn) {
      return;
    }

    // The callback `fn` might be used for multiple nodes/events. Since we generate
    // a wrapper function, we need to keep track of it when we remove the listener.
    // It's more efficient to store the node/type/options information as Array in
    // `fn` itself rather than the node (we assume that the same callback is used
    // for few nodes at most, whereas a node will likely have many event listeners).
    // NOTE(valdrin) invoking external functions is costly, inline has better perf.
    var capture = void 0,
        once = void 0,
        passive = void 0;
    if ((typeof optionsOrCapture === 'undefined' ? 'undefined' : _typeof(optionsOrCapture)) === 'object') {
      capture = Boolean(optionsOrCapture.capture);
      once = Boolean(optionsOrCapture.once);
      passive = Boolean(optionsOrCapture.passive);
    } else {
      capture = Boolean(optionsOrCapture);
      once = false;
      passive = false;
    }
    if (fn.__eventWrappers) {
      // Stop if the wrapper function has already been created.
      for (var i = 0; i < fn.__eventWrappers.length; i++) {
        if (fn.__eventWrappers[i].node === this && fn.__eventWrappers[i].type === type && fn.__eventWrappers[i].capture === capture && fn.__eventWrappers[i].once === once && fn.__eventWrappers[i].passive === passive) {
          return;
        }
      }
    } else {
      fn.__eventWrappers = [];
    }

    var wrapperFn = function wrapperFn(e) {
      // Support `once` option.
      if (once) {
        this.removeEventListener(type, fn, optionsOrCapture);
      }
      if (!e.__target) {
        e.__target = e.target;
        e.__relatedTarget = e.relatedTarget;
        patchPrototype(e, EventMixin);
      }
      // There are two critera that should stop events from firing on this node
      // 1. the event is not composed and the current node is not in the same root as the target
      // 2. when bubbling, if after retargeting, relatedTarget and target point to the same node
      if (e.composed || e.composedPath().indexOf(this) > -1) {
        if (e.eventPhase === Event.BUBBLING_PHASE) {
          if (e.target === e.relatedTarget) {
            e.stopImmediatePropagation();
            return;
          }
        }
        return fn(e);
      }
    };
    // Store the wrapper information.
    fn.__eventWrappers.push({
      node: this,
      type: type,
      capture: capture,
      once: once,
      passive: passive,
      wrapperFn: wrapperFn
    });

    if (nonBubblingEventsToRetarget[type]) {
      this.__handlers = this.__handlers || {};
      this.__handlers[type] = this.__handlers[type] || { capture: [], bubble: [] };
      this.__handlers[type][capture ? 'capture' : 'bubble'].push(wrapperFn);
    } else {
      origAddEventListener.call(this, type, wrapperFn, optionsOrCapture);
    }
  }

  function removeEventListener(type, fn, optionsOrCapture) {
    if (!fn) {
      return;
    }

    // NOTE(valdrin) invoking external functions is costly, inline has better perf.
    var capture = void 0,
        once = void 0,
        passive = void 0;
    if ((typeof optionsOrCapture === 'undefined' ? 'undefined' : _typeof(optionsOrCapture)) === 'object') {
      capture = Boolean(optionsOrCapture.capture);
      once = Boolean(optionsOrCapture.once);
      passive = Boolean(optionsOrCapture.passive);
    } else {
      capture = Boolean(optionsOrCapture);
      once = false;
      passive = false;
    }
    // Search the wrapped function.
    var wrapperFn = undefined;
    if (fn.__eventWrappers) {
      for (var i = 0; i < fn.__eventWrappers.length; i++) {
        if (fn.__eventWrappers[i].node === this && fn.__eventWrappers[i].type === type && fn.__eventWrappers[i].capture === capture && fn.__eventWrappers[i].once === once && fn.__eventWrappers[i].passive === passive) {
          wrapperFn = fn.__eventWrappers.splice(i, 1)[0].wrapperFn;
          // Cleanup.
          if (!fn.__eventWrappers.length) {
            fn.__eventWrappers = undefined;
          }
          break;
        }
      }
    }

    origRemoveEventListener.call(this, type, wrapperFn || fn, optionsOrCapture);
    if (wrapperFn && nonBubblingEventsToRetarget[type] && this.__handlers && this.__handlers[type]) {
      var arr = this.__handlers[type][capture ? 'capture' : 'bubble'];
      var idx = arr.indexOf(wrapperFn);
      if (idx > -1) {
        arr.splice(idx, 1);
      }
    }
  }

  function activateFocusEventOverrides() {
    for (var ev in nonBubblingEventsToRetarget) {
      window.addEventListener(ev, function (e) {
        if (!e.__target) {
          e.__target = e.target;
          e.__relatedTarget = e.relatedTarget;
          patchPrototype(e, EventMixin);
          retargetNonBubblingEvent(e);
          e.stopImmediatePropagation();
        }
      }, true);
    }
  }

  var PatchedEvent = mixinComposedFlag(Event);
  var PatchedCustomEvent = mixinComposedFlag(CustomEvent);
  var PatchedMouseEvent = mixinComposedFlag(MouseEvent);

  /**
  @license
  Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */

  /**
   * Patches elements that interacts with ShadyDOM
   * such that tree traversal and mutation apis act like they would under
   * ShadowDOM.
   *
   * This import enables seemless interaction with ShadyDOM powered
   * custom elements, enabling better interoperation with 3rd party code,
   * libraries, and frameworks that use DOM tree manipulation apis.
   */

  // TODO(sorvell): remove when code that depends on this is moved to dom-mixin
  if (settings.inUse) {
    (function () {

      window.ShadyDOM = {
        // TODO(sorvell): remove when Polymer does not depend on this.
        inUse: settings.inUse,
        // TODO(sorvell): remove when Polymer does not depend on this.
        patch: function patch(node) {
          return node;
        },
        getComposedInnerHTML: getComposedInnerHTML,
        getComposedChildNodes: getComposedChildNodes,
        isShadyRoot: isShadyRoot,
        // TODO(sorvell): exposed for testing only, worth it?
        enqueue: enqueue,
        flush: flush,
        settings: settings,
        filterMutations: filterMutations,
        observeChildren: observeChildren,
        unobserveChildren: unobserveChildren,
        nativeMethods: nativeMethods
      };

      var createRootAndEnsurePatched = function createRootAndEnsurePatched(node) {
        // TODO(sorvell): need to ensure ancestors are patched but this introduces
        // a timing problem with gathering composed children.
        // (1) currently the child list is crawled and patched when patching occurs
        // (this needs to change)
        // (2) we can only patch when an element has received its parsed children
        // because we cannot detect them when inserted by parser.
        // let ancestor = node;
        // while (ancestor) {
        //   patchNode(ancestor);
        //   ancestor = ancestor.parentNode || ancestor.host;
        // }
        //patch.patchNode(node);
        var root = new ShadyRoot(node);
        //patch.patchNode(root);
        return root;
      };

      Element.prototype.attachShadow = function () {
        return createRootAndEnsurePatched(this);
      };

      Node.prototype.addEventListener = addEventListener;
      Node.prototype.removeEventListener = removeEventListener;
      Event = PatchedEvent;
      CustomEvent = PatchedCustomEvent;
      MouseEvent = PatchedMouseEvent;
      activateFocusEventOverrides();

      Object.defineProperty(Node.prototype, 'isConnected', {
        get: function get() {
          return document.documentElement.contains(this);
        },

        configurable: true
      });

      Node.prototype.getRootNode = function (options) {
        return getRootNode(this, options);
      };

      Object.defineProperty(Element.prototype, 'slot', {
        get: function get() {
          return this.getAttribute('slot');
        },
        set: function set(value) {
          this.setAttribute('slot', value);
        },

        configurable: true
      });

      Object.defineProperty(Node.prototype, 'assignedSlot', {
        get: function get() {
          return this.__shady && this.__shady.assignedSlot || null;
        },

        configurable: true
      });

      // let nativeSetAttribute = Element.prototype.setAttribute;
      // Element.prototype.setAttribute = setAttribute;
      // NOTE: expose native setAttribute to allow hooking native method
      // (e.g. this is done in ShadyCSS)

      var classNameDescriptor = {
        get: function get() {
          return this.getAttribute('class');
        },
        set: function set(value) {
          this.setAttribute('class', value);
        },

        configurable: true
      };

      // Safari 9 `className` is not configurable
      var cn = Object.getOwnPropertyDescriptor(Element.prototype, 'className');
      if (cn && cn.configurable) {
        Object.defineProperty(Element.prototype, 'className', classNameDescriptor);
      } else {
        // on IE `className` is on Element
        var h = window.customElements && window.customElements.nativeHTMLElement || HTMLElement;
        cn = Object.getOwnPropertyDescriptor(h.prototype, 'className');
        if (cn && cn.configurable) {
          Object.defineProperty(h.prototype, 'className', classNameDescriptor);
        }
      }

      patchProto(Node.prototype, Mixins.Node);
      patchProto(Text.prototype, Mixins.Text);
      patchProto(DocumentFragment.prototype, Mixins.Fragment);
      patchProto(Element.prototype, Mixins.Element);
      var he = window.customElements && customElements.nativeHTMLElement || HTMLElement;
      patchProto(he.prototype, Mixins.HTMLElement, true);
      patchProto(Document.prototype, Mixins.Document);
      if (window.HTMLSlotElement) {
        patchProto(HTMLSlotElement.prototype, Mixins.Slot);
      }

      // Safari 9 testing
      // patchProto(Text.prototype, Mixins.Node);
      // patchProto(he.prototype, Mixins.Node);
      // patchProto(he.prototype, Mixins.Element);
    })();
  }
})();
//# sourceMappingURL=shadydom.min.js.map
