{"version":3,"sources":["utils.js","array-splice.js","tree.js","shady.js","innerHTML.js","element-mixin.js","patch.js","event-mixin.js","distributor.js","env.js"],"names":["isShadyRoot","obj","Boolean","__localName","matchesSelector","element","selector","matches","call","copyOwnProperty","name","source","target","let","pd","Object","getOwnPropertyDescriptor","defineProperty","extend","n","n$","getOwnPropertyNames","i","length","extendAll","sources","mixin","patchPrototype","proto","getPrototypeOf","hasOwnProperty","patchProto","create","__sourceProto","__patchProto","setPrototypeOf","newSplice","index","removed","addedCount","getNativeProperty","property","descriptors","HTMLElement","prototype","Element","Node","get","enqueue","callback","scheduled","utils.promish","then","flush","flushList","push","flushCount","shift","customElements","const","isFlushedMaxed","flushMax","Error","escapeReplace","c","escapeAttr","s","replace","escapeAttrRegExp","escapeData","escapeDataRegExp","makeSet","arr","set","getOuterHTML","node","parentNode","composed","nodeType","ELEMENT_NODE","attr","tagName","localName","attrs","attributes","value","voidElements","getInnerHTML","TEXT_NODE","data","plaintextParents","COMMENT_NODE","window","console","error","content","child","c$","childNodes","l","filterMutations","mutations","targetRootNode","getRootNode","filter","mutation","mutationInScope","addedNodes","nodes","Array","from","configurable","patchNode","utils.settings","inUse","isNodePatched","patchImpl","canPatchNode","tree","saveChildNodes","patch","unpatchNode","unpatch","__patched","pathComposer","startNode","composedPath","current","startRoot","assignedSlot","DOCUMENT_FRAGMENT_NODE","host","document","retarget","refNode","path","utils.isShadyRoot","ancestor","lastRoot","root","rootIdx","refNodePath","p$","indexOf","mixinComposedFlag","Base","klazz","type","options","event","__composed","utils.mixin","fireHandlers","phase","hs","__handlers","fn","__immediatePropagationStopped","retargetNonBubblingEvent","e","__propagationStopped","Event","AT_TARGET","lastFiredRoot","shadowRoot","addEventListener","optionsOrCapture","capture","once","passive","__eventWrappers","this","wrapperFn","removeEventListener","__target","__relatedTarget","relatedTarget","utils.patchPrototype","EventMixin","eventPhase","BUBBLING_PHASE","stopImmediatePropagation","nonBubblingEventsToRetarget","bubble","origAddEventListener","undefined","splice","origRemoveEventListener","idx","activateFocusEventOverrides","ev","settings","ShadyDOM","hasNativeShadowDOM","attachShadow","force","promish","p","mozMatchesSelector","msMatchesSelector","oMatchesSelector","webkitMatchesSelector","common","Promise","resolve","cb","twiddle","createTextNode","observer","MutationObserver","disconnect","observe","characterData","EDIT_LEAVE","EDIT_UPDATE","EDIT_ADD","EDIT_DELETE","ArraySplice","calcEditDistances","currentStart","currentEnd","old","oldStart","oldEnd","rowCount","columnCount","distances","j","equals","north","west","spliceOperationsFromEditDistances","edits","min","northWest","reverse","calcSplices","prefixCount","suffixCount","minLength","Math","sharedPrefix","sharedSuffix","ops","splices","oldIndex","searchLength","index1","index2","count","calculateSplices","previous","currentValue","previousValue","nativeInsertBefore","insertBefore","nativeAppendChild","appendChild","nativeRemoveChild","removeChild","arrayCopyChildNodes","parent","copy","firstChild","nextSibling","arrayCopyChildren","firstElementChild","nextElementSibling","arrayCopy","a$","Logical","Composed","hasParentNode","saveComposedData","__dom","hasChildNodes","getChildNodes","_getChildNodes","getFirstChild","getNextSibling","getParentNode","getLastChild","lastChild","getPreviousSibling","previousSibling","getFirstElementChild","_getFirstElementChild","getLastElementChild","_getLastElementChild","getNextElementSibling","_getNextElementSibling","getPreviousElementSibling","_getPreviousElementSibling","utils.common","recordInsertBefore","container","ref_node","_linkNode","recordRemoveChild","$parentNode","$childNodes","$firstChild","$nextSibling","getComposedChildNodes","$lastChild","$previousSibling","lastElementChild","previousElementSibling","clearChildNodes","saveParentNode","newChild","refChild","_addChild","currentParent","_removeChild","isFrag","oldParent","NormalizedEvent","inType","params","createEvent","initEvent","bubbles","cancelable","Distributor","anonymous","insertionPointTag","getInsertionPoints","querySelectorAll","hasInsertionPoint","_insertionPoints","isInsertionPoint","distribute","distributePool","collectPool","pool","dirtyRoots","distributeInsertionPoint","shadyRoot","_assignedSlot","insertionPoint","prevAssignedNodes","_assignedNodes","clearAssignedSlots","needsSlotChange","anyDistributed","matchesInsertionPoint","__prevAssignedSlot","distributeNodeInto","children","setDistributedNodesOnInsertionPoint","_fireSlotChange","slot","savePrevious","slotName","getAttribute","trim","_distributedNodes","d$","dispatchEvent","isFinalDestination","ShadyRoot","frag","createDocumentFragment","__proto__","ShadyFragmentMixin","_init","ShadyMixin","_clean","_hasRendered","_distributor","update","distributionRoot","_findDistributionRoot","render","_elementNeedsDistribution","_skipUpdateInsertionPoints","updateInsertionPoints","compose","forceRender","i$","__insertionPoints","insertionPoints","_composeTree","_updateChildNodes","_composeNode","distributedNodes","distributedNode","d","next","getInsertionPointTag","DocumentFragment","utils.extend","list","mixinImpl","addNode","ownerRoot","ownerShadyRootForNode","__noInsertionPoint","ipAdded","_maybeAddInsertionPoint","_addedNode","handled","_maybeDistribute","removeNode","distributed","logicalParent","maybeDistributeParent","_removeDistributedChildren","_removeOwnerShadyRoot","_removedNode","_scheduleObserver","addedNode","removedNode","removedNodes","schedule","removeNodeFromParent","_hasCachedOwnerRoot","__ownerShadyRoot","documentElement","contains","fragContent","querySelector","wrappedContent","hasContent","needsDist","_nodeNeedsDistribution","added","np","na","hostNeedsDist","ip$","_contains","dc$","assignedNodes","flatten","firstComposedNode","clearNode","maybeDistributeAttributeChange","query","matcher","halter","_queryElements","elements","_queryElement","result","activeElementForNode","active","activeElement","activeRoot","nativeCloneNode","cloneNode","nativeImportNode","Document","importNode","nativeSetAttribute","setAttribute","nativeRemoveAttribute","removeAttribute","NodeMixin","defineProperties","parentElement","FragmentMixin","replaceChild","utils.matchesSelector","deep","nc","externalNode","doc","ownerDocument","isArray","textContent","tc","cn","join","text","innerHTML","createElement","ElementMixin","activeElementDescriptor","ActiveElementMixin","UnderActiveElementMixin","_activeElement","Mixins","utils.extendAll","Fragment","AsyncObserver","_scheduled","callbacks","Set","this$1","takeRecords","forEach","observeChildren","add","_callback","_observer","_node","unobserveChildren","handle","delete","size","patchedCount","log","head","hasPrototypeDescriptors","warn","mixinForObject","mixinForNode","DOCUMENT_NODE","alwaysComposed","blur","focus","focusin","focusout","click","dblclick","mousedown","mouseenter","mouseleave","mousemove","mouseout","mouseover","mouseup","wheel","beforeinput","input","keydown","keyup","compositionstart","compositionupdate","compositionend","touchstart","touchend","touchmove","touchcancel","pointerover","pointerenter","pointerdown","pointermove","pointerup","pointercancel","pointerout","pointerleave","gotpointercapture","lostpointercapture","dragstart","drag","dragenter","dragleave","dragover","drop","dragend","DOMActivate","DOMFocusIn","DOMFocusOut","keypress","isTrusted","__composedPath","currentTarget","__relatedTargetComposedPath","stopPropagation","PatchedEvent","PatchedCustomEvent","CustomEvent","PatchedMouseEvent","MouseEvent","patch.patchNode","isPatched","patch.isNodePatched","patch.unpatchNode","createRootAndEnsurePatched","events.addEventListener","events.removeEventListener","events.PatchedEvent","events.PatchedCustomEvent","events.PatchedMouseEvent","events.activateFocusEventOverrides"],"mappings":"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","file":"shadydom.min.js","sourcesContent":["/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n'use strict';\n\nexport let settings = window.ShadyDOM || {};\n\nsettings.hasNativeShadowDOM = Boolean(Element.prototype.attachShadow && Node.prototype.getRootNode);\n\nsettings.inUse = settings.force || !settings.hasNativeShadowDOM;\n\nexport function isShadyRoot(obj) {\n  return Boolean(obj.__localName === 'ShadyRoot');\n}\n\nlet p = Element.prototype;\nlet matches = p.matches || p.matchesSelector ||\n  p.mozMatchesSelector || p.msMatchesSelector ||\n  p.oMatchesSelector || p.webkitMatchesSelector;\n\nexport function matchesSelector(element, selector) {\n  return matches.call(element, selector);\n}\n\nfunction copyOwnProperty(name, source, target) {\n  let pd = Object.getOwnPropertyDescriptor(source, name);\n  if (pd) {\n    Object.defineProperty(target, name, pd);\n  }\n}\n\nexport function extend(target, source) {\n  if (target && source) {\n    let n$ = Object.getOwnPropertyNames(source);\n    for (let i=0, n; (i<n$.length) && (n=n$[i]); i++) {\n      copyOwnProperty(n, source, target);\n    }\n  }\n  return target || source;\n}\n\nexport function extendAll(target, ...sources) {\n  for (let i=0; i < sources.length; i++) {\n    extend(target, sources[i]);\n  }\n  return target;\n}\n\nexport function mixin(target, source) {\n  for (var i in source) {\n    target[i] = source[i];\n  }\n  return target;\n}\n\nexport function patchPrototype(obj, mixin) {\n  let proto = Object.getPrototypeOf(obj);\n  if (!proto.hasOwnProperty('__patchProto')) {\n    let patchProto = Object.create(proto);\n    patchProto.__sourceProto = proto;\n    extend(patchProto, mixin);\n    proto.__patchProto = patchProto;\n  }\n  Object.setPrototypeOf(obj, proto.__patchProto);\n}\n\nexport function unpatchPrototype(obj) {\n  if (obj.__sourceProto) {\n    Object.setPrototypeOf(obj, obj.__sourceProto);\n  }\n}\n\nexport let common = {};\n\n// TODO(sorvell): actually rely on a real Promise polyfill...\nexport let promish;\nif (window.Promise) {\n  promish = Promise.resolve();\n} else {\n  promish = {\n    then: function(cb) {\n      let twiddle = document.createTextNode('');\n      let observer = new MutationObserver(function() {\n        observer.disconnect();\n        cb();\n      });\n      observer.observe(twiddle, {characterData: true});\n    }\n  }\n}","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n'use strict';\n\nfunction newSplice(index, removed, addedCount) {\n  return {\n    index: index,\n    removed: removed,\n    addedCount: addedCount\n  };\n}\n\nconst EDIT_LEAVE = 0;\nconst EDIT_UPDATE = 1;\nconst EDIT_ADD = 2;\nconst EDIT_DELETE = 3;\n\nlet ArraySplice = {\n\n  // Note: This function is *based* on the computation of the Levenshtein\n  // \"edit\" distance. The one change is that \"updates\" are treated as two\n  // edits - not one. With Array splices, an update is really a delete\n  // followed by an add. By retaining this, we optimize for \"keeping\" the\n  // maximum array items in the original array. For example:\n  //\n  //   'xxxx123' -> '123yyyy'\n  //\n  // With 1-edit updates, the shortest path would be just to update all seven\n  // characters. With 2-edit updates, we delete 4, leave 3, and add 4. This\n  // leaves the substring '123' intact.\n  calcEditDistances(current, currentStart, currentEnd,\n                              old, oldStart, oldEnd) {\n    // \"Deletion\" columns\n    let rowCount = oldEnd - oldStart + 1;\n    let columnCount = currentEnd - currentStart + 1;\n    let distances = new Array(rowCount);\n\n    // \"Addition\" rows. Initialize null column.\n    for (let i = 0; i < rowCount; i++) {\n      distances[i] = new Array(columnCount);\n      distances[i][0] = i;\n    }\n\n    // Initialize null row\n    for (let j = 0; j < columnCount; j++)\n      distances[0][j] = j;\n\n    for (let i = 1; i < rowCount; i++) {\n      for (let j = 1; j < columnCount; j++) {\n        if (this.equals(current[currentStart + j - 1], old[oldStart + i - 1]))\n          distances[i][j] = distances[i - 1][j - 1];\n        else {\n          let north = distances[i - 1][j] + 1;\n          let west = distances[i][j - 1] + 1;\n          distances[i][j] = north < west ? north : west;\n        }\n      }\n    }\n\n    return distances;\n  },\n\n  // This starts at the final weight, and walks \"backward\" by finding\n  // the minimum previous weight recursively until the origin of the weight\n  // matrix.\n  spliceOperationsFromEditDistances(distances) {\n    let i = distances.length - 1;\n    let j = distances[0].length - 1;\n    let current = distances[i][j];\n    let edits = [];\n    while (i > 0 || j > 0) {\n      if (i == 0) {\n        edits.push(EDIT_ADD);\n        j--;\n        continue;\n      }\n      if (j == 0) {\n        edits.push(EDIT_DELETE);\n        i--;\n        continue;\n      }\n      let northWest = distances[i - 1][j - 1];\n      let west = distances[i - 1][j];\n      let north = distances[i][j - 1];\n\n      let min;\n      if (west < north)\n        min = west < northWest ? west : northWest;\n      else\n        min = north < northWest ? north : northWest;\n\n      if (min == northWest) {\n        if (northWest == current) {\n          edits.push(EDIT_LEAVE);\n        } else {\n          edits.push(EDIT_UPDATE);\n          current = northWest;\n        }\n        i--;\n        j--;\n      } else if (min == west) {\n        edits.push(EDIT_DELETE);\n        i--;\n        current = west;\n      } else {\n        edits.push(EDIT_ADD);\n        j--;\n        current = north;\n      }\n    }\n\n    edits.reverse();\n    return edits;\n  },\n\n  /**\n   * Splice Projection functions:\n   *\n   * A splice map is a representation of how a previous array of items\n   * was transformed into a new array of items. Conceptually it is a list of\n   * tuples of\n   *\n   *   <index, removed, addedCount>\n   *\n   * which are kept in ascending index order of. The tuple represents that at\n   * the |index|, |removed| sequence of items were removed, and counting forward\n   * from |index|, |addedCount| items were added.\n   */\n\n  /**\n   * Lacking individual splice mutation information, the minimal set of\n   * splices can be synthesized given the previous state and final state of an\n   * array. The basic approach is to calculate the edit distance matrix and\n   * choose the shortest path through it.\n   *\n   * Complexity: O(l * p)\n   *   l: The length of the current array\n   *   p: The length of the old array\n   */\n  calcSplices(current, currentStart, currentEnd,\n                        old, oldStart, oldEnd) {\n    let prefixCount = 0;\n    let suffixCount = 0;\n    let splice;\n\n    let minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);\n    if (currentStart == 0 && oldStart == 0)\n      prefixCount = this.sharedPrefix(current, old, minLength);\n\n    if (currentEnd == current.length && oldEnd == old.length)\n      suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);\n\n    currentStart += prefixCount;\n    oldStart += prefixCount;\n    currentEnd -= suffixCount;\n    oldEnd -= suffixCount;\n\n    if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)\n      return [];\n\n    if (currentStart == currentEnd) {\n      splice = newSplice(currentStart, [], 0);\n      while (oldStart < oldEnd)\n        splice.removed.push(old[oldStart++]);\n\n      return [ splice ];\n    } else if (oldStart == oldEnd)\n      return [ newSplice(currentStart, [], currentEnd - currentStart) ];\n\n    let ops = this.spliceOperationsFromEditDistances(\n        this.calcEditDistances(current, currentStart, currentEnd,\n                               old, oldStart, oldEnd));\n\n    splice = undefined;\n    let splices = [];\n    let index = currentStart;\n    let oldIndex = oldStart;\n    for (let i = 0; i < ops.length; i++) {\n      switch(ops[i]) {\n        case EDIT_LEAVE:\n          if (splice) {\n            splices.push(splice);\n            splice = undefined;\n          }\n\n          index++;\n          oldIndex++;\n          break;\n        case EDIT_UPDATE:\n          if (!splice)\n            splice = newSplice(index, [], 0);\n\n          splice.addedCount++;\n          index++;\n\n          splice.removed.push(old[oldIndex]);\n          oldIndex++;\n          break;\n        case EDIT_ADD:\n          if (!splice)\n            splice = newSplice(index, [], 0);\n\n          splice.addedCount++;\n          index++;\n          break;\n        case EDIT_DELETE:\n          if (!splice)\n            splice = newSplice(index, [], 0);\n\n          splice.removed.push(old[oldIndex]);\n          oldIndex++;\n          break;\n      }\n    }\n\n    if (splice) {\n      splices.push(splice);\n    }\n    return splices;\n  },\n\n  sharedPrefix(current, old, searchLength) {\n    for (let i = 0; i < searchLength; i++)\n      if (!this.equals(current[i], old[i]))\n        return i;\n    return searchLength;\n  },\n\n  sharedSuffix(current, old, searchLength) {\n    let index1 = current.length;\n    let index2 = old.length;\n    let count = 0;\n    while (count < searchLength && this.equals(current[--index1], old[--index2]))\n      count++;\n\n    return count;\n  },\n\n  calculateSplices(current, previous) {\n    return this.calcSplices(current, 0, current.length, previous, 0,\n                            previous.length);\n  },\n\n  equals(currentValue, previousValue) {\n    return currentValue === previousValue;\n  }\n\n};\n\nexport let calculateSplices = (current, previous) =>\n  ArraySplice.calculateSplices(current, previous);\n","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n'use strict';\n\n// TODO(sorvell): circular (patch loads tree and tree loads patch)\n// for now this is stuck on `utils`\n//import {patchNode} from './patch'\nimport * as utils from './utils'\n\n// native add/remove\nlet nativeInsertBefore = Element.prototype.insertBefore;\nlet nativeAppendChild = Element.prototype.appendChild;\nlet nativeRemoveChild = Element.prototype.removeChild;\n\n/**\n * `tree` is a dom manipulation library used by ShadyDom to\n * manipulate composed and logical trees.\n */\nexport let tree = {\n\n  // sad but faster than slice...\n  arrayCopyChildNodes(parent) {\n    let copy=[], i=0;\n    for (let n=parent.firstChild; n; n=n.nextSibling) {\n      copy[i++] = n;\n    }\n    return copy;\n  },\n\n  arrayCopyChildren(parent) {\n    let copy=[], i=0;\n    for (let n=parent.firstElementChild; n; n=n.nextElementSibling) {\n      copy[i++] = n;\n    }\n    return copy;\n  },\n\n  arrayCopy(a$) {\n    let l = a$.length;\n    let copy = new Array(l);\n    for (let i=0; i < l; i++) {\n      copy[i] = a$[i];\n    }\n    return copy;\n  },\n\n  saveChildNodes(node) {\n    tree.Logical.saveChildNodes(node);\n    if (!tree.Composed.hasParentNode(node)) {\n      tree.Composed.saveComposedData(node);\n      //tree.Composed.saveParentNode(node);\n    }\n    tree.Composed.saveChildNodes(node);\n  }\n\n};\n\ntree.Logical = {\n\n  hasParentNode(node) {\n    return Boolean(node.__dom && node.__dom.parentNode);\n  },\n\n  hasChildNodes(node) {\n    return Boolean(node.__dom && node.__dom.childNodes !== undefined);\n  },\n\n  getChildNodes(node) {\n    // note: we're distinguishing here between undefined and false-y:\n    // hasChildNodes uses undefined check to see if this element has logical\n    // children; the false-y check indicates whether or not we should rebuild\n    // the cached childNodes array.\n    return this.hasChildNodes(node) ? this._getChildNodes(node) :\n      tree.Composed.getChildNodes(node);\n  },\n\n  _getChildNodes(node) {\n    if (!node.__dom.childNodes) {\n      node.__dom.childNodes = [];\n      for (let n=this.getFirstChild(node); n; n=this.getNextSibling(n)) {\n        node.__dom.childNodes.push(n);\n      }\n    }\n    return node.__dom.childNodes;\n  },\n\n  // NOTE: __dom can be created under 2 conditions: (1) an element has a\n  // logical tree, or (2) an element is in a logical tree. In case (1), the\n  // element will store firstChild/lastChild, and in case (2), the element\n  // will store parentNode, nextSibling, previousSibling. This means that\n  // the mere existence of __dom is not enough to know if the requested\n  // logical data is available and instead we do an explicit undefined check.\n  getParentNode(node) {\n    return node.__dom && node.__dom.parentNode !== undefined ?\n      node.__dom.parentNode : tree.Composed.getParentNode(node);\n  },\n\n  getFirstChild(node) {\n    return node.__dom && node.__dom.firstChild !== undefined ?\n      node.__dom.firstChild : tree.Composed.getFirstChild(node);\n  },\n\n  getLastChild(node) {\n    return node.__dom && node.__dom.lastChild  !== undefined ?\n      node.__dom.lastChild : tree.Composed.getLastChild(node);\n  },\n\n  getNextSibling(node) {\n    return node.__dom && node.__dom.nextSibling  !== undefined ?\n      node.__dom.nextSibling : tree.Composed.getNextSibling(node);\n  },\n\n  getPreviousSibling(node) {\n    return node.__dom && node.__dom.previousSibling  !== undefined ?\n      node.__dom.previousSibling : tree.Composed.getPreviousSibling(node);\n  },\n\n  getFirstElementChild(node) {\n    return node.__dom && node.__dom.firstChild !== undefined ?\n      this._getFirstElementChild(node) :\n      tree.Composed.getFirstElementChild(node);\n  },\n\n  _getFirstElementChild(node) {\n    let n = node.__dom.firstChild;\n    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n      n = n.__dom.nextSibling;\n    }\n    return n;\n  },\n\n  getLastElementChild(node) {\n    return node.__dom && node.__dom.lastChild !== undefined ?\n      this._getLastElementChild(node) :\n      tree.Composed.getLastElementChild(node);\n  },\n\n  _getLastElementChild(node) {\n    let n = node.__dom.lastChild;\n    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n      n = n.__dom.previousSibling;\n    }\n    return n;\n  },\n\n  getNextElementSibling(node) {\n    return node.__dom && node.__dom.nextSibling !== undefined ?\n      this._getNextElementSibling(node) :\n      tree.Composed.getNextElementSibling(node);\n  },\n\n  _getNextElementSibling(node) {\n    let n = node.__dom.nextSibling;\n    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n      n = this.getNextSibling(n);\n    }\n    return n;\n  },\n\n  getPreviousElementSibling(node) {\n    return node.__dom && node.__dom.previousSibling !== undefined ?\n      this._getPreviousElementSibling(node) :\n      tree.Composed.getPreviousElementSibling(node);\n  },\n\n  _getPreviousElementSibling(node) {\n    let n = node.__dom.previousSibling;\n    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n      n = this.getPreviousSibling(n);\n    }\n    return n;\n  },\n\n  // Capture the list of light children. It's important to do this before we\n  // start transforming the DOM into \"rendered\" state.\n  // Children may be added to this list dynamically. It will be treated as the\n  // source of truth for the light children of the element. This element's\n  // actual children will be treated as the rendered state once this function\n  // has been called.\n  saveChildNodes(node) {\n    if (!this.hasChildNodes(node)) {\n      node.__dom = node.__dom || {};\n      node.__dom.firstChild = node.firstChild;\n      node.__dom.lastChild = node.lastChild;\n      let c$ = node.__dom.childNodes = tree.arrayCopyChildNodes(node);\n      for (let i=0, n; (i<c$.length) && (n=c$[i]); i++) {\n        n.__dom = n.__dom || {};\n        n.__dom.parentNode = node;\n        n.__dom.nextSibling = c$[i+1] || null;\n        n.__dom.previousSibling = c$[i-1] || null;\n        utils.common.patchNode(n);\n      }\n    }\n  },\n\n  // TODO(sorvell): may need to patch saveChildNodes iff the tree has\n  // already been distributed.\n  // NOTE: ensure `node` is patched...\n  recordInsertBefore(node, container, ref_node) {\n    container.__dom.childNodes = null;\n    // handle document fragments\n    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n      let c$ = tree.arrayCopyChildNodes(node);\n      for (let i=0; i < c$.length; i++) {\n        this._linkNode(c$[i], container, ref_node);\n      }\n      // cleanup logical dom in doc fragment.\n      node.__dom = node.__dom || {};\n      node.__dom.firstChild = node.__dom.lastChild = null;\n      node.__dom.childNodes = null;\n    } else {\n      this._linkNode(node, container, ref_node);\n    }\n  },\n\n  _linkNode(node, container, ref_node) {\n    utils.common.patchNode(node);\n    ref_node = ref_node || null;\n    node.__dom = node.__dom || {};\n    container.__dom = container.__dom || {};\n    if (ref_node) {\n      ref_node.__dom = ref_node.__dom || {};\n    }\n    // update ref_node.previousSibling <-> node\n    node.__dom.previousSibling = ref_node ? ref_node.__dom.previousSibling :\n      container.__dom.lastChild;\n    if (node.__dom.previousSibling) {\n      node.__dom.previousSibling.__dom.nextSibling = node;\n    }\n    // update node <-> ref_node\n    node.__dom.nextSibling = ref_node;\n    if (node.__dom.nextSibling) {\n      node.__dom.nextSibling.__dom.previousSibling = node;\n    }\n    // update node <-> container\n    node.__dom.parentNode = container;\n    if (ref_node) {\n      if (ref_node === container.__dom.firstChild) {\n        container.__dom.firstChild = node;\n      }\n    } else {\n      container.__dom.lastChild = node;\n      if (!container.__dom.firstChild) {\n        container.__dom.firstChild = node;\n      }\n    }\n    // remove caching of childNodes\n    container.__dom.childNodes = null;\n  },\n\n  recordRemoveChild(node, container) {\n    node.__dom = node.__dom || {};\n    container.__dom = container.__dom || {};\n    if (node === container.__dom.firstChild) {\n      container.__dom.firstChild = node.__dom.nextSibling;\n    }\n    if (node === container.__dom.lastChild) {\n      container.__dom.lastChild = node.__dom.previousSibling;\n    }\n    let p = node.__dom.previousSibling;\n    let n = node.__dom.nextSibling;\n    if (p) {\n      p.__dom = p.__dom || {};\n      p.__dom.nextSibling = n;\n    }\n    if (n) {\n      n.__dom = n.__dom || {};\n      n.__dom.previousSibling = p;\n    }\n    // When an element is removed, logical data is no longer tracked.\n    // Explicitly set `undefined` here to indicate this. This is disginguished\n    // from `null` which is set if info is null.\n    node.__dom.parentNode = node.__dom.previousSibling =\n      node.__dom.nextSibling = null;\n    // remove caching of childNodes\n    container.__dom.childNodes = null;\n  }\n\n}\n\n\n// TODO(sorvell): composed tree manipulation is made available\n// (1) to maninpulate the composed tree, and (2) to track changes\n// to the tree for optional patching pluggability.\ntree.Composed = {\n\n  hasParentNode(node) {\n    return Boolean(node.__dom && node.__dom.$parentNode !== undefined);\n  },\n\n  hasChildNodes(node) {\n    return Boolean(node.__dom && node.__dom.$childNodes !== undefined);\n  },\n\n  getChildNodes(node) {\n    return this.hasChildNodes(node) ? this._getChildNodes(node) :\n      (!node.__patched && tree.arrayCopy(node.childNodes));\n  },\n\n  _getChildNodes(node) {\n    if (!node.__dom.$childNodes) {\n      node.__dom.$childNodes = [];\n      for (let n=node.__dom.$firstChild; n; n=n.__dom.$nextSibling) {\n        node.__dom.$childNodes.push(n);\n      }\n    }\n    return node.__dom.$childNodes;\n  },\n\n  getComposedChildNodes(node) {\n    return node.__dom.$childNodes;\n  },\n\n  getParentNode(node) {\n    return this.hasParentNode(node) ? node.__dom.$parentNode :\n      (!node.__patched && node.parentNode);\n  },\n\n  getFirstChild(node) {\n    return node.__patched ? node.__dom.$firstChild : node.firstChild;\n  },\n\n  getLastChild(node) {\n    return node.__patched ? node.__dom.$lastChild : node.lastChild;\n  },\n\n  getNextSibling(node) {\n    return node.__patched ? node.__dom.$nextSibling : node.nextSibling;\n  },\n\n  getPreviousSibling(node) {\n    return node.__patched ? node.__dom.$previousSibling : node.previousSibling;\n  },\n\n  getFirstElementChild(node) {\n    return node.__patched ? this._getFirstElementChild(node) :\n      node.firstElementChild;\n  },\n\n  _getFirstElementChild(node) {\n    let n = node.__dom.$firstChild;\n    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n      n = n.__dom.$nextSibling;\n    }\n    return n;\n  },\n\n  getLastElementChild(node) {\n    return node.__patched ? this._getLastElementChild(node) :\n      node.lastElementChild;\n  },\n\n  _getLastElementChild(node) {\n    let n = node.__dom.$lastChild;\n    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n      n = n.__dom.$previousSibling;\n    }\n    return n;\n  },\n\n  getNextElementSibling(node) {\n    return node.__patched ? this._getNextElementSibling(node) :\n      node.nextElementSibling;\n  },\n\n  _getNextElementSibling(node) {\n    let n = node.__dom.$nextSibling;\n    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n      n = this.getNextSibling(n);\n    }\n    return n;\n  },\n\n  getPreviousElementSibling(node) {\n    return node.__patched ? this._getPreviousElementSibling(node) :\n      node.previousElementSibling;\n  },\n\n  _getPreviousElementSibling(node) {\n    let n = node.__dom.$previousSibling;\n    while (n && n.nodeType !== Node.ELEMENT_NODE) {\n      n = this.getPreviousSibling(n);\n    }\n    return n;\n  },\n\n  saveChildNodes(node) {\n    if (!this.hasChildNodes(node)) {\n      node.__dom = node.__dom || {};\n      node.__dom.$firstChild = node.firstChild;\n      node.__dom.$lastChild = node.lastChild;\n      let c$ = node.__dom.$childNodes = tree.arrayCopyChildNodes(node);\n      for (let i=0, n; (i<c$.length) && (n=c$[i]); i++) {\n        this.saveComposedData(n);\n      }\n    }\n  },\n\n  saveComposedData(node) {\n    node.__dom = node.__dom || {};\n    if (node.__dom.$parentNode === undefined) {\n      node.__dom.$parentNode = node.parentNode;\n    }\n    if (node.__dom.$nextSibling === undefined) {\n      node.__dom.$nextSibling = node.nextSibling;\n    }\n    if (node.__dom.$previousSibling === undefined) {\n      node.__dom.$previousSibling = node.previousSibling;\n    }\n  },\n\n  recordInsertBefore(node, container, ref_node) {\n    container.__dom.$childNodes = null;\n    // handle document fragments\n    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n      // TODO(sorvell): remember this for patching:\n      // the act of setting this info can affect patched nodes\n      // getters; therefore capture childNodes before patching.\n      for (let n=this.getFirstChild(node); n; n=this.getNextSibling(n)) {\n        this._linkNode(n, container, ref_node);\n      }\n    } else {\n      this._linkNode(node, container, ref_node);\n    }\n  },\n\n  _linkNode(node, container, ref_node) {\n    node.__dom = node.__dom || {};\n    container.__dom = container.__dom || {};\n    if (ref_node) {\n      ref_node.__dom = ref_node.__dom || {};\n    }\n    // update ref_node.previousSibling <-> node\n    node.__dom.$previousSibling = ref_node ? ref_node.__dom.$previousSibling :\n      container.__dom.$lastChild;\n    if (node.__dom.$previousSibling) {\n      node.__dom.$previousSibling.__dom.$nextSibling = node;\n    }\n    // update node <-> ref_node\n    node.__dom.$nextSibling = ref_node;\n    if (node.__dom.$nextSibling) {\n      node.__dom.$nextSibling.__dom.$previousSibling = node;\n    }\n    // update node <-> container\n    node.__dom.$parentNode = container;\n    if (ref_node) {\n      if (ref_node === container.__dom.$firstChild) {\n        container.__dom.$firstChild = node;\n      }\n    } else {\n      container.__dom.$lastChild = node;\n      if (!container.__dom.$firstChild) {\n        container.__dom.$firstChild = node;\n      }\n    }\n    // remove caching of childNodes\n    container.__dom.$childNodes = null;\n  },\n\n  recordRemoveChild(node, container) {\n    node.__dom = node.__dom || {};\n    container.__dom = container.__dom || {};\n    if (node === container.__dom.$firstChild) {\n      container.__dom.$firstChild = node.__dom.$nextSibling;\n    }\n    if (node === container.__dom.$lastChild) {\n      container.__dom.$lastChild = node.__dom.$previousSibling;\n    }\n    let p = node.__dom.$previousSibling;\n    let n = node.__dom.$nextSibling;\n    if (p) {\n      p.__dom = p.__dom || {};\n      p.__dom.$nextSibling = n;\n    }\n    if (n) {\n      n.__dom = n.__dom || {};\n      n.__dom.$previousSibling = p;\n    }\n    node.__dom.$parentNode = node.__dom.$previousSibling =\n      node.__dom.$nextSibling = null;\n    // remove caching of childNodes\n    container.__dom.$childNodes = null;\n  },\n\n  clearChildNodes(node) {\n    let c$ = this.getChildNodes(node);\n    for (let i=0, c; i < c$.length; i++) {\n      c = c$[i];\n      this.recordRemoveChild(c, node);\n      nativeRemoveChild.call(node, c)\n    }\n  },\n\n  saveParentNode(node) {\n    node.__dom = node.__dom || {};\n    node.__dom.$parentNode = node.parentNode;\n  },\n\n  insertBefore(parentNode, newChild, refChild) {\n    this.saveChildNodes(parentNode);\n    // remove from current location.\n    this._addChild(parentNode, newChild, refChild);\n    return nativeInsertBefore.call(parentNode, newChild, refChild || null);\n  },\n\n  appendChild(parentNode, newChild) {\n    this.saveChildNodes(parentNode);\n    this._addChild(parentNode, newChild);\n    return nativeAppendChild.call(parentNode, newChild);\n  },\n\n  removeChild(parentNode, node) {\n    let currentParent = this.getParentNode(node);\n    this.saveChildNodes(parentNode);\n    this._removeChild(parentNode, node);\n    if (currentParent === parentNode) {\n      return nativeRemoveChild.call(parentNode, node);\n    }\n  },\n\n  _addChild(parentNode, newChild, refChild) {\n    let isFrag = (newChild.nodeType === Node.DOCUMENT_FRAGMENT_NODE);\n    let oldParent = this.getParentNode(newChild);\n    if (oldParent) {\n      this._removeChild(oldParent, newChild);\n    }\n    if (isFrag) {\n      let c$ = this.getChildNodes(newChild);\n      for (let i=0; i < c$.length; i++) {\n        let c = c$[i];\n        // unlink document fragment children\n        this._removeChild(newChild, c);\n        this.recordInsertBefore(c, parentNode, refChild);\n      }\n    } else {\n      this.recordInsertBefore(newChild, parentNode, refChild);\n    }\n  },\n\n  _removeChild(parentNode, node) {\n    this.recordRemoveChild(node, parentNode);\n  }\n\n};\n\n// for testing...\nlet descriptors = {};\nexport function getNativeProperty(element, property) {\n  if (!descriptors[property]) {\n    descriptors[property] = Object.getOwnPropertyDescriptor(\n      HTMLElement.prototype, property) ||\n    Object.getOwnPropertyDescriptor(\n      Element.prototype, property) ||\n    Object.getOwnPropertyDescriptor(\n      Node.prototype, property);\n  }\n  return descriptors[property].get.call(element);\n}\n\n// for testing...\nfunction assertNative(element, property, tracked) {\n  let native = getNativeProperty(element, property);\n  if (native != tracked && element.__patched) {\n    window.console.warn('tracked', tracked, 'native', native);\n  }\n  return tracked;\n}","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n'use strict';\n\nimport {calculateSplices} from './array-splice'\nimport * as utils from './utils'\nimport {tree} from './tree'\nimport Distributor from './distributor'\n\n/**\n  Implements a pared down version of ShadowDOM's scoping, which is easy to\n  polyfill across browsers.\n*/\nexport class ShadyRoot {\n\n  constructor(host) {\n    if (!host) {\n      throw 'Must provide a host';\n    }\n    // NOTE: this strange construction is necessary because\n    // DocumentFragment cannot be subclassed on older browsers.\n    let frag = document.createDocumentFragment();\n    frag.__proto__ = ShadyFragmentMixin;\n    frag._init(host);\n    return frag;\n  }\n\n}\n\nlet ShadyMixin = {\n\n  _init(host) {\n    // NOTE: set a fake local name so this element can be\n    // distinguished from a DocumentFragment when patching.\n    // FF doesn't allow this to be `localName`\n    this.__localName = 'ShadyRoot';\n    // root <=> host\n    host.shadyRoot = this;\n    this.host = host;\n    // logical dom setup\n    tree.Logical.saveChildNodes(host);\n    tree.Logical.saveChildNodes(this);\n    // state flags\n    this._clean = true;\n    this._hasRendered = false;\n    this._distributor = new Distributor(this);\n    this.update();\n  },\n\n  // async render the \"top\" distributor (this is all that is needed to\n  // distribute this host).\n  update() {\n    // TODO(sorvell): instead the root should always be enqueued to helps record that it is dirty.\n    // Then, in `render`, the top most (in the distribution tree) \"dirty\" root should be rendered.\n    let distributionRoot = this._findDistributionRoot(this.host);\n    //console.log('update from', this.host, 'root', distributionRoot.host, distributionRoot._clean);\n    if (distributionRoot._clean) {\n      distributionRoot._clean = false;\n      enqueue(function() {\n        distributionRoot.render();\n      });\n    }\n  },\n\n  // TODO(sorvell): this may not return a shadowRoot (for example if the element is in a docFragment)\n  // this should only return a shadowRoot.\n  // returns the host that's the top of this host's distribution tree\n  _findDistributionRoot(element) {\n    let root = element.shadyRoot;\n    while (element && this._elementNeedsDistribution(element)) {\n      root = element.getRootNode();\n      element = root && root.host;\n    }\n    return root;\n  },\n\n  // Return true if a host's children includes\n  // an insertion point that selects selectively\n  _elementNeedsDistribution(element) {\n    let c$ = tree.Logical.getChildNodes(element);\n    for (let i=0, c; i < c$.length; i++) {\n      c = c$[i];\n      if (this._distributor.isInsertionPoint(c)) {\n        return element.getRootNode();\n      }\n    }\n  },\n\n  render() {\n    if (!this._clean) {\n      this._clean = true;\n      if (!this._skipUpdateInsertionPoints) {\n        this.updateInsertionPoints();\n      } else if (!this._hasRendered) {\n        this._insertionPoints = [];\n      }\n      this._skipUpdateInsertionPoints = false;\n      // TODO(sorvell): previous ShadyDom had a fast path here\n      // that would avoid distribution for initial render if\n      // no insertion points exist. We cannot currently do this because\n      // it relies on elements being in the physical shadowRoot element\n      // so that native methods will be used. The current append code\n      // simply provokes distribution in this case and does not put the\n      // nodes in the shadowRoot. This could be done but we'll need to\n      // consider if the special processing is worth the perf gain.\n      // if (!this._hasRendered && !this._insertionPoints.length) {\n      //   tree.Composed.clearChildNodes(this.host);\n      //   tree.Composed.appendChild(this.host, this);\n      // } else {\n      // logical\n      this.distribute();\n      // physical\n      this.compose();\n      this._hasRendered = true;\n    }\n  },\n\n  forceRender() {\n    this._clean = false;\n    this.render();\n  },\n\n  distribute() {\n    let dirtyRoots = this._distributor.distribute();\n    for (let i=0; i<dirtyRoots.length; i++) {\n      dirtyRoots[i].forceRender();\n    }\n  },\n\n  updateInsertionPoints() {\n    let i$ = this.__insertionPoints;\n    // if any insertion points have been removed, clear their distribution info\n    if (i$) {\n      for (let i=0, c; i < i$.length; i++) {\n        c = i$[i];\n        if (c.getRootNode() !== this) {\n          this._distributor.clearAssignedSlots(c);\n        }\n      }\n    }\n    i$ = this._insertionPoints = this._distributor.getInsertionPoints();\n    // ensure insertionPoints's and their parents have logical dom info.\n    // save logical tree info\n    // a. for shadyRoot\n    // b. for insertion points (fallback)\n    // c. for parents of insertion points\n    for (let i=0, c; i < i$.length; i++) {\n      c = i$[i];\n      tree.Logical.saveChildNodes(c);\n      tree.Logical.saveChildNodes(tree.Logical.getParentNode(c));\n    }\n  },\n\n  get _insertionPoints() {\n    if (!this.__insertionPoints) {\n      this.updateInsertionPoints();\n    }\n    return this.__insertionPoints || (this.__insertionPoints = []);\n  },\n\n  set _insertionPoints(insertionPoints) {\n    this.__insertionPoints = insertionPoints;\n  },\n\n  hasInsertionPoint() {\n    return this._distributor.hasInsertionPoint();\n  },\n\n  compose() {\n    // compose self\n    // note: it's important to mark this clean before distribution\n    // so that attachment that provokes additional distribution (e.g.\n    // adding something to your parentNode) works\n    this._composeTree();\n    // TODO(sorvell): See fast paths here in Polymer v1\n    // (these seem unnecessary)\n  },\n\n  // Reify dom such that it is at its correct rendering position\n  // based on logical distribution.\n  _composeTree() {\n    this._updateChildNodes(this.host, this._composeNode(this.host));\n    let p$ = this._insertionPoints || [];\n    for (let i=0, l=p$.length, p, parent; (i<l) && (p=p$[i]); i++) {\n      parent = tree.Logical.getParentNode(p);\n      if ((parent !== this.host) && (parent !== this)) {\n        this._updateChildNodes(parent, this._composeNode(parent));\n      }\n    }\n  },\n\n  // Returns the list of nodes which should be rendered inside `node`.\n  _composeNode(node) {\n    let children = [];\n    let c$ = tree.Logical.getChildNodes(node.shadyRoot || node);\n    for (let i = 0; i < c$.length; i++) {\n      let child = c$[i];\n      if (this._distributor.isInsertionPoint(child)) {\n        let distributedNodes = child._distributedNodes ||\n          (child._distributedNodes = []);\n        for (let j = 0; j < distributedNodes.length; j++) {\n          let distributedNode = distributedNodes[j];\n          if (this.isFinalDestination(child, distributedNode)) {\n            children.push(distributedNode);\n          }\n        }\n      } else {\n        children.push(child);\n      }\n    }\n    return children;\n  },\n\n  isFinalDestination(insertionPoint, node) {\n    return this._distributor.isFinalDestination(\n      insertionPoint, node);\n  },\n\n  // Ensures that the rendered node list inside `container` is `children`.\n  _updateChildNodes(container, children) {\n    let composed = tree.Composed.getChildNodes(container);\n    let splices = calculateSplices(children, composed);\n    // process removals\n    for (let i=0, d=0, s; (i<splices.length) && (s=splices[i]); i++) {\n      for (let j=0, n; (j < s.removed.length) && (n=s.removed[j]); j++) {\n        // check if the node is still where we expect it is before trying\n        // to remove it; this can happen if we move a node and\n        // then schedule its previous host for distribution resulting in\n        // the node being removed here.\n        if (tree.Composed.getParentNode(n) === container) {\n          tree.Composed.removeChild(container, n);\n        }\n        composed.splice(s.index + d, 1);\n      }\n      d -= s.addedCount;\n    }\n    // process adds\n    for (let i=0, s, next; (i<splices.length) && (s=splices[i]); i++) { //eslint-disable-line no-redeclare\n      next = composed[s.index];\n      for (let j=s.index, n; j < s.index + s.addedCount; j++) {\n        n = children[j];\n        tree.Composed.insertBefore(container, n, next);\n        // TODO(sorvell): is this splice strictly needed?\n        composed.splice(j, 0, n);\n      }\n    }\n  },\n\n  getInsertionPointTag() {\n    return this._distributor.insertionPointTag;\n  }\n\n}\n\nlet ShadyFragmentMixin = Object.create(DocumentFragment.prototype);\nutils.extend(ShadyFragmentMixin, ShadyMixin);\n\n// let needsUpgrade = window.CustomElements && !CustomElements.useNative;\n\n// function upgradeLogicalChildren(children) {\n//   if (needsUpgrade && children) {\n//     for (let i=0; i < children.length; i++) {\n//       CustomElements.upgrade(children[i]);\n//     }\n//   }\n// }\n\n// render enqueuer/flusher\nlet customElements = window.customElements;\nlet flushList = [];\nlet scheduled;\nlet flushCount = 0;\nlet flushMax = 100;\nexport function enqueue(callback) {\n  if (!scheduled) {\n    scheduled = true;\n    utils.promish.then(flush);\n  }\n  flushList.push(callback);\n}\n\nexport function flush() {\n  scheduled = false;\n  flushCount++;\n  while (flushList.length) {\n    flushList.shift()();\n  }\n  if (customElements && customElements.flush) {\n    customElements.flush();\n  }\n  // continue flushing after elements are upgraded...\n  const isFlushedMaxed = (flushCount > flushMax);\n  if (flushList.length && !isFlushedMaxed) {\n      flush();\n  }\n  flushCount = 0;\n  if (isFlushedMaxed) {\n    throw new Error('Loop detected in ShadyDOM distribution, aborting.')\n  }\n}\n\nflush.list = flushList;","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n'use strict';\n\n// Cribbed from ShadowDOM polyfill\n// https://github.com/webcomponents/webcomponentsjs/blob/master/src/ShadowDOM/wrappers/HTMLElement.js#L28\n/////////////////////////////////////////////////////////////////////////////\n// innerHTML and outerHTML\n\n// http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#escapingString\nlet escapeAttrRegExp = /[&\\u00A0\"]/g;\nlet escapeDataRegExp = /[&\\u00A0<>]/g;\n\nfunction escapeReplace(c) {\n  switch (c) {\n    case '&':\n      return '&amp;';\n    case '<':\n      return '&lt;';\n    case '>':\n      return '&gt;';\n    case '\"':\n      return '&quot;';\n    case '\\u00A0':\n      return '&nbsp;';\n  }\n}\n\nfunction escapeAttr(s) {\n  return s.replace(escapeAttrRegExp, escapeReplace);\n}\n\nfunction escapeData(s) {\n  return s.replace(escapeDataRegExp, escapeReplace);\n}\n\nfunction makeSet(arr) {\n  let set = {};\n  for (let i = 0; i < arr.length; i++) {\n    set[arr[i]] = true;\n  }\n  return set;\n}\n\n// http://www.whatwg.org/specs/web-apps/current-work/#void-elements\nlet voidElements = makeSet([\n  'area',\n  'base',\n  'br',\n  'col',\n  'command',\n  'embed',\n  'hr',\n  'img',\n  'input',\n  'keygen',\n  'link',\n  'meta',\n  'param',\n  'source',\n  'track',\n  'wbr'\n]);\n\nlet plaintextParents = makeSet([\n  'style',\n  'script',\n  'xmp',\n  'iframe',\n  'noembed',\n  'noframes',\n  'plaintext',\n  'noscript'\n]);\n\nexport function getOuterHTML(node, parentNode, composed) {\n  switch (node.nodeType) {\n    case Node.ELEMENT_NODE: {\n      let tagName = node.localName;\n      let s = '<' + tagName;\n      let attrs = node.attributes;\n      for (let i = 0, attr; (attr = attrs[i]); i++) {\n        s += ' ' + attr.name + '=\"' + escapeAttr(attr.value) + '\"';\n      }\n      s += '>';\n      if (voidElements[tagName]) {\n        return s;\n      }\n      return s + getInnerHTML(node, composed) + '</' + tagName + '>';\n    }\n    case Node.TEXT_NODE: {\n      let data = node.data;\n      if (parentNode && plaintextParents[parentNode.localName]) {\n        return data;\n      }\n      return escapeData(data);\n    }\n    case Node.COMMENT_NODE: {\n      return '<!--' + node.data + '-->';\n    }\n    default: {\n      window.console.error(node);\n      throw new Error('not implemented');\n    }\n  }\n}\n\nexport function getInnerHTML(node, composed) {\n  if (node.localName === 'template') {\n    node = node.content;\n  }\n  let s = '';\n  let c$ = composed ? composed(node) : node.childNodes;\n  for (let i=0, l=c$.length, child; (i<l) && (child=c$[i]); i++) {\n    s += getOuterHTML(child, node, composed);\n  }\n  return s;\n}","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n'use strict';\n\nimport * as utils from './utils'\nimport {getInnerHTML} from './innerHTML'\nimport {tree} from './tree'\n\nlet mixinImpl = {\n\n  // Try to add node. Record logical info, track insertion points, perform\n  // distribution iff needed. Return true if the add is handled.\n  addNode(container, node, ref_node) {\n    let ownerRoot = this.ownerShadyRootForNode(container);\n    if (ownerRoot) {\n      // optimization: special insertion point tracking\n      if (node.__noInsertionPoint) {\n        ownerRoot._skipUpdateInsertionPoints = true;\n      }\n      // note: we always need to see if an insertion point is added\n      // since this saves logical tree info; however, invalidation state\n      // needs\n      let ipAdded = this._maybeAddInsertionPoint(node, container, ownerRoot);\n      // invalidate insertion points IFF not already invalid!\n      if (ipAdded) {\n        ownerRoot._skipUpdateInsertionPoints = false;\n      }\n      this._addedNode(node, ownerRoot);\n    }\n    if (tree.Logical.hasChildNodes(container)) {\n      tree.Logical.recordInsertBefore(node, container, ref_node);\n    }\n    // if not distributing and not adding to host, do a fast path addition\n    let handled = this._maybeDistribute(node, container, ownerRoot) ||\n      container.shadyRoot;\n    return handled;\n  },\n\n  // Try to remove node: update logical info and perform distribution iff\n  // needed. Return true if the removal has been handled.\n  // note that it's possible for both the node's host and its parent\n  // to require distribution... both cases are handled here.\n  removeNode(node) {\n    // important that we want to do this only if the node has a logical parent\n    let logicalParent = tree.Logical.hasParentNode(node) &&\n      tree.Logical.getParentNode(node);\n    let distributed;\n    let ownerRoot = this.ownerShadyRootForNode(node);\n    if (logicalParent) {\n      // distribute node's parent iff needed\n      distributed = this.maybeDistributeParent(node);\n      tree.Logical.recordRemoveChild(node, logicalParent);\n      // remove node from root and distribute it iff needed\n      if (ownerRoot && (this._removeDistributedChildren(ownerRoot, node) ||\n        logicalParent.localName === ownerRoot.getInsertionPointTag())) {\n        ownerRoot._skipUpdateInsertionPoints = false;\n        ownerRoot.update();\n      }\n    }\n    this._removeOwnerShadyRoot(node);\n    if (ownerRoot) {\n      this._removedNode(node, ownerRoot);\n    }\n    return distributed;\n  },\n\n\n  _scheduleObserver(node, addedNode, removedNode) {\n    let observer = node.__dom && node.__dom.observer;\n    if (observer) {\n      if (addedNode) {\n        observer.addedNodes.push(addedNode);\n      }\n      if (removedNode) {\n        observer.removedNodes.push(removedNode);\n      }\n      observer.schedule();\n    }\n  },\n\n  removeNodeFromParent(node, parent) {\n    if (parent) {\n      this._scheduleObserver(parent, null, node);\n      this.removeNode(node);\n    } else {\n      this._removeOwnerShadyRoot(node);\n    }\n  },\n\n  _hasCachedOwnerRoot(node) {\n    return Boolean(node.__ownerShadyRoot !== undefined);\n  },\n\n  getRootNode(node) {\n    if (!node || !node.nodeType) {\n      return;\n    }\n    let root = node.__ownerShadyRoot;\n    if (root === undefined) {\n      if (utils.isShadyRoot(node)) {\n        root = node;\n      } else {\n        let parent = tree.Logical.getParentNode(node);\n        root = parent ? this.getRootNode(parent) : node;\n      }\n      // memo-ize result for performance but only memo-ize\n      // result if node is in the document. This avoids a problem where a root\n      // can be cached while an element is inside a fragment.\n      // If this happens and we cache the result, the value can become stale\n      // because for perf we avoid processing the subtree of added fragments.\n      if (document.documentElement.contains(node)) {\n        node.__ownerShadyRoot = root;\n      }\n    }\n    return root;\n  },\n\n  ownerShadyRootForNode(node) {\n    let root = this.getRootNode(node);\n    if (utils.isShadyRoot(root)) {\n      return root;\n    }\n  },\n\n  _maybeDistribute(node, container, ownerRoot) {\n    // TODO(sorvell): technically we should check non-fragment nodes for\n    // <content> children but since this case is assumed to be exceedingly\n    // rare, we avoid the cost and will address with some specific api\n    // when the need arises.  For now, the user must call\n    // distributeContent(true), which updates insertion points manually\n    // and forces distribution.\n    let insertionPointTag = ownerRoot && ownerRoot.getInsertionPointTag() || '';\n    let fragContent = (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) &&\n      !node.__noInsertionPoint &&\n      insertionPointTag && node.querySelector(insertionPointTag);\n    let wrappedContent = fragContent &&\n      (tree.Logical.getParentNode(fragContent).nodeType !==\n      Node.DOCUMENT_FRAGMENT_NODE);\n    let hasContent = fragContent || (node.localName === insertionPointTag);\n    // There are 3 possible cases where a distribution may need to occur:\n    // 1. <content> being inserted (the host of the shady root where\n    //    content is inserted needs distribution)\n    // 2. children being inserted into parent with a shady root (parent\n    //    needs distribution)\n    // 3. container is an insertionPoint\n    if (hasContent || (container.localName === insertionPointTag)) {\n      if (ownerRoot) {\n        // note, insertion point list update is handled after node\n        // mutations are complete\n        ownerRoot.update();\n      }\n    }\n    let needsDist = this._nodeNeedsDistribution(container);\n    if (needsDist) {\n      container.shadyRoot.update();\n    }\n    // Return true when distribution will fully handle the composition\n    // Note that if a content was being inserted that was wrapped by a node,\n    // and the parent does not need distribution, return false to allow\n    // the nodes to be added directly, after which children may be\n    // distributed and composed into the wrapping node(s)\n    return needsDist || (hasContent && !wrappedContent);\n  },\n\n  /* note: parent argument is required since node may have an out\n  of date parent at this point; returns true if a <content> is being added */\n  _maybeAddInsertionPoint(node, parent, root) {\n    let added;\n    let insertionPointTag = root.getInsertionPointTag();\n    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE &&\n      !node.__noInsertionPoint) {\n      let c$ = node.querySelectorAll(insertionPointTag);\n      for (let i=0, n, np, na; (i<c$.length) && (n=c$[i]); i++) {\n        np = tree.Logical.getParentNode(n);\n        // don't allow node's parent to be fragment itself\n        if (np === node) {\n          np = parent;\n        }\n        na = this._maybeAddInsertionPoint(n, np, root);\n        added = added || na;\n      }\n    } else if (node.localName === insertionPointTag) {\n      tree.Logical.saveChildNodes(parent);\n      tree.Logical.saveChildNodes(node);\n      added = true;\n    }\n    return added;\n  },\n\n  _nodeNeedsDistribution(node) {\n    return node && node.shadyRoot &&\n      node.shadyRoot.hasInsertionPoint();\n  },\n\n  // TODO(sorvell): needed for style scoping, use MO?\n  _addedNode() {},\n  _removedNode() {},\n  /*\n  _addedNode(node, root) {\n    // if (ShadyDOM.addedNode) {\n    //   ShadyDOM.addedNode(node, root);\n    // }\n  },\n\n  _removedNode(node, root) {\n    if (ShadyDOM.removedNode) {\n      ShadyDOM.removedNode(node, root);\n    }\n  },\n  */\n\n  _removeDistributedChildren(root, container) {\n    let hostNeedsDist;\n    let ip$ = root._insertionPoints;\n    for (let i=0; i<ip$.length; i++) {\n      let insertionPoint = ip$[i];\n      if (this._contains(container, insertionPoint)) {\n        let dc$ = insertionPoint.assignedNodes({flatten: true});\n        for (let j=0; j<dc$.length; j++) {\n          hostNeedsDist = true;\n          let node = dc$[j];\n          let parent = tree.Composed.getParentNode(node);\n          if (parent) {\n            tree.Composed.removeChild(parent, node);\n          }\n        }\n      }\n    }\n    return hostNeedsDist;\n  },\n\n  _contains(container, node) {\n    while (node) {\n      if (node == container) {\n        return true;\n      }\n      node = tree.Logical.getParentNode(node);\n    }\n  },\n\n  _removeOwnerShadyRoot(node) {\n    // optimization: only reset the tree if node is actually in a root\n    if (this._hasCachedOwnerRoot(node)) {\n      let c$ = tree.Logical.getChildNodes(node);\n      for (let i=0, l=c$.length, n; (i<l) && (n=c$[i]); i++) {\n        this._removeOwnerShadyRoot(n);\n      }\n    }\n    node.__ownerShadyRoot = undefined;\n  },\n\n  // TODO(sorvell): This will fail if distribution that affects this\n  // question is pending; this is expected to be exceedingly rare, but if\n  // the issue comes up, we can force a flush in this case.\n  firstComposedNode(insertionPoint) {\n    let n$ = insertionPoint.assignedNodes({flatten: true});\n    let root = this.getRootNode(insertionPoint);\n    for (let i=0, l=n$.length, n; (i<l) && (n=n$[i]); i++) {\n      // means that we're composed to this spot.\n      if (root.isFinalDestination(insertionPoint, n)) {\n        return n;\n      }\n    }\n  },\n\n  clearNode(node) {\n    while (node.firstChild) {\n      node.removeChild(node.firstChild);\n    }\n  },\n\n  maybeDistributeParent(node) {\n    let parent = tree.Logical.getParentNode(node);\n    if (this._nodeNeedsDistribution(parent)) {\n      parent.shadyRoot.update();\n      return true;\n    }\n  },\n\n  maybeDistributeAttributeChange(node, name) {\n    let distribute = (node.localName === 'slot' && name === 'name');\n    if (distribute) {\n      let root = this.getRootNode(node);\n      if (root.update) {\n        root.update();\n      }\n    }\n  },\n\n  // NOTE: `query` is used primarily for ShadyDOM's querySelector impl,\n  // but it's also generally useful to recurse through the element tree\n  // and is used by Polymer's styling system.\n  query(node, matcher, halter) {\n    let list = [];\n    this._queryElements(tree.Logical.getChildNodes(node), matcher,\n      halter, list);\n    return list;\n  },\n\n  _queryElements(elements, matcher, halter, list) {\n    for (let i=0, l=elements.length, c; (i<l) && (c=elements[i]); i++) {\n      if (c.nodeType === Node.ELEMENT_NODE &&\n          this._queryElement(c, matcher, halter, list)) {\n        return true;\n      }\n    }\n  },\n\n  _queryElement(node, matcher, halter, list) {\n    let result = matcher(node);\n    if (result) {\n      list.push(node);\n    }\n    if (halter && halter(result)) {\n      return result;\n    }\n    this._queryElements(tree.Logical.getChildNodes(node), matcher,\n      halter, list);\n  },\n\n  activeElementForNode(node) {\n    let active = document.activeElement;\n    if (!active) {\n      return null;\n    }\n    let isShadyRoot = !!(utils.isShadyRoot(node));\n    if (node !== document) {\n      // If this node isn't a document or shady root, then it doesn't have\n      // an active element.\n      if (!isShadyRoot) {\n        return null;\n      }\n      // If this shady root's host is the active element or the active\n      // element is not a descendant of the host (in the composed tree),\n      // then it doesn't have an active element.\n      if (node.host === active ||\n          !node.host.contains(active)) {\n        return null;\n      }\n    }\n    // This node is either the document or a shady root of which the active\n    // element is a (composed) descendant of its host; iterate upwards to\n    // find the active element's most shallow host within it.\n    let activeRoot = this.ownerShadyRootForNode(active);\n    while (activeRoot && activeRoot !== node) {\n      active = activeRoot.host;\n      activeRoot = this.ownerShadyRootForNode(active);\n    }\n    if (node === document) {\n      // This node is the document, so activeRoot should be null.\n      return activeRoot ? null : active;\n    } else {\n      // This node is a non-document shady root, and it should be\n      // activeRoot.\n      return activeRoot === node ? active : null;\n    }\n  }\n\n};\n\nlet nativeCloneNode = Element.prototype.cloneNode;\nlet nativeImportNode = Document.prototype.importNode;\nlet nativeSetAttribute = Element.prototype.setAttribute;\nlet nativeRemoveAttribute = Element.prototype.removeAttribute;\n\nlet NodeMixin = {};\n\nObject.defineProperties(NodeMixin, {\n\n  parentElement: {\n    get() {\n      return tree.Logical.getParentNode(this);\n    },\n    configurable: true\n  },\n\n  parentNode: {\n    get() {\n      return tree.Logical.getParentNode(this);\n    },\n    configurable: true\n  },\n\n  nextSibling: {\n    get() {\n      return tree.Logical.getNextSibling(this);\n    },\n    configurable: true\n  },\n\n  previousSibling: {\n    get() {\n      return tree.Logical.getPreviousSibling(this);\n    },\n    configurable: true\n  },\n\n  nextElementSibling: {\n    get() {\n      return tree.Logical.getNextElementSibling(this);\n    },\n    configurable: true\n  },\n\n  previousElementSibling: {\n    get() {\n      return tree.Logical.getPreviousElementSibling(this);\n    },\n    configurable: true\n  },\n\n  assignedSlot: {\n    get() {\n      return this._assignedSlot;\n    },\n    configurable: true\n  }\n});\n\nlet FragmentMixin = {\n\n  appendChild(node) {\n    return this.insertBefore(node);\n  },\n\n  // cases in which we may not be able to just do standard native call\n  // 1. container has a shadyRoot (needsDistribution IFF the shadyRoot\n  // has an insertion point)\n  // 2. container is a shadyRoot (don't distribute, instead set\n  // container to container.host.\n  // 3. node is <content> (host of container needs distribution)\n  insertBefore(node, ref_node) {\n    if (ref_node && tree.Logical.getParentNode(ref_node) !== this) {\n      throw Error('The ref_node to be inserted before is not a child ' +\n        'of this node');\n    }\n    // remove node from its current position iff it's in a tree.\n    if (node.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {\n      let parent = tree.Logical.getParentNode(node);\n      mixinImpl.removeNodeFromParent(node, parent);\n    }\n    if (!mixinImpl.addNode(this, node, ref_node)) {\n      if (ref_node) {\n        // if ref_node is an insertion point replace with first distributed node\n        let root = mixinImpl.ownerShadyRootForNode(ref_node);\n        if (root) {\n          ref_node = ref_node.localName === root.getInsertionPointTag() ?\n            mixinImpl.firstComposedNode(ref_node) : ref_node;\n        }\n      }\n      // if adding to a shadyRoot, add to host instead\n      let container = utils.isShadyRoot(this) ?\n        this.host : this;\n      if (ref_node) {\n        tree.Composed.insertBefore(container, node, ref_node);\n      } else {\n        tree.Composed.appendChild(container, node);\n      }\n    }\n    mixinImpl._scheduleObserver(this, node);\n    return node;\n  },\n\n  /**\n    Removes the given `node` from the element's `lightChildren`.\n    This method also performs dom composition.\n  */\n  removeChild(node) {\n    if (tree.Logical.getParentNode(node) !== this) {\n      throw Error('The node to be removed is not a child of this node: ' +\n        node);\n    }\n    if (!mixinImpl.removeNode(node)) {\n      // if removing from a shadyRoot, remove form host instead\n      let container = utils.isShadyRoot(this) ?\n        this.host :\n        this;\n      // not guaranteed to physically be in container; e.g.\n      // undistributed nodes.\n      let parent = tree.Composed.getParentNode(node);\n      if (container === parent) {\n        tree.Composed.removeChild(container, node);\n      }\n    }\n    mixinImpl._scheduleObserver(this, null, node);\n    return node;\n  },\n\n  replaceChild(node, ref_node) {\n    this.insertBefore(node, ref_node);\n    this.removeChild(ref_node);\n    return node;\n  },\n\n  // TODO(sorvell): consider doing native QSA and filtering results.\n  querySelector(selector) {\n    // match selector and halt on first result.\n    let result = mixinImpl.query(this, function(n) {\n      return utils.matchesSelector(n, selector);\n    }, function(n) {\n      return Boolean(n);\n    })[0];\n    return result || null;\n  },\n\n  querySelectorAll(selector) {\n    return mixinImpl.query(this, function(n) {\n      return utils.matchesSelector(n, selector);\n    });\n  },\n\n  cloneNode(deep) {\n    if (this.localName == 'template') {\n      return nativeCloneNode.call(this, deep);\n    } else {\n      let n = nativeCloneNode.call(this, false);\n      if (deep) {\n        let c$ = this.childNodes;\n        for (let i=0, nc; i < c$.length; i++) {\n          nc = c$[i].cloneNode(true);\n          n.appendChild(nc);\n        }\n      }\n      return n;\n    }\n  },\n\n  importNode(externalNode, deep) {\n    // for convenience use this node's ownerDoc if the node isn't a document\n    let doc = this instanceof Document ? this :\n      this.ownerDocument;\n    let n = nativeImportNode.call(doc, externalNode, false);\n    if (deep) {\n      let c$ = tree.Logical.getChildNodes(externalNode);\n      utils.common.patchNode(n);\n      for (let i=0, nc; i < c$.length; i++) {\n        nc = doc.importNode(c$[i], true);\n        n.appendChild(nc);\n      }\n    }\n    return n;\n  }\n};\n\nObject.defineProperties(FragmentMixin, {\n\n  childNodes: {\n    get() {\n      let c$ = tree.Logical.getChildNodes(this);\n      return Array.isArray(c$) ? c$ : tree.arrayCopyChildNodes(this);\n    },\n    configurable: true\n  },\n\n  children: {\n    get() {\n      if (tree.Logical.hasChildNodes(this)) {\n        return Array.prototype.filter.call(this.childNodes, function(n) {\n          return (n.nodeType === Node.ELEMENT_NODE);\n        });\n      } else {\n        return tree.arrayCopyChildren(this);\n      }\n    },\n    configurable: true\n  },\n\n  firstChild: {\n    get() {\n      return tree.Logical.getFirstChild(this);\n    },\n    configurable: true\n  },\n\n  lastChild: {\n    get() {\n      return tree.Logical.getLastChild(this);\n    },\n    configurable: true\n  },\n\n  firstElementChild: {\n    get() {\n      return tree.Logical.getFirstElementChild(this);\n    },\n    configurable: true\n  },\n\n  lastElementChild: {\n    get() {\n      return tree.Logical.getLastElementChild(this);\n    },\n    configurable: true\n  },\n\n  // TODO(srovell): strictly speaking fragments do not have textContent\n  // or innerHTML but ShadowRoots do and are not easily distinguishable.\n  // textContent / innerHTML\n  textContent: {\n    get() {\n      if (this.childNodes) {\n        let tc = [];\n        for (let i = 0, cn = this.childNodes, c; (c = cn[i]); i++) {\n          if (c.nodeType !== Node.COMMENT_NODE) {\n            tc.push(c.textContent);\n          }\n        }\n        return tc.join('');\n      }\n      return '';\n    },\n    set(text) {\n      mixinImpl.clearNode(this);\n      if (text) {\n        this.appendChild(document.createTextNode(text));\n      }\n    },\n    configurable: true\n  },\n\n  innerHTML: {\n    get() {\n      return getInnerHTML(this);\n    },\n    set(text) {\n      mixinImpl.clearNode(this);\n      let d = document.createElement('div');\n      d.innerHTML = text;\n      // here, appendChild may move nodes async so we cannot rely\n      // on node position when copying\n      let c$ = tree.arrayCopyChildNodes(d);\n      for (let i=0; i < c$.length; i++) {\n        this.appendChild(c$[i]);\n      }\n    },\n    configurable: true\n  }\n\n});\n\nlet ElementMixin = {\n\n  // TODO(sorvell): should only exist on <slot>\n  assignedNodes(options) {\n    return (options && options.flatten ? this._distributedNodes :\n      this._assignedNodes) || [];\n  },\n\n\n  setAttribute(name, value) {\n    nativeSetAttribute.call(this, name, value);\n    if (!mixinImpl.maybeDistributeParent(this)) {\n      mixinImpl.maybeDistributeAttributeChange(this, name);\n    }\n  },\n\n  removeAttribute(name) {\n    nativeRemoveAttribute.call(this, name);\n    if (!mixinImpl.maybeDistributeParent(this)) {\n      mixinImpl.maybeDistributeAttributeChange(this, name);\n    }\n  }\n\n};\n\nObject.defineProperties(ElementMixin, {\n\n  shadowRoot: {\n    get() {\n      return this.shadyRoot;\n    }\n  },\n\n  slot: {\n    get() {\n      return this.getAttribute('slot');\n    },\n    set(value) {\n      this.setAttribute('slot', value);\n    }\n  }\n\n});\n\nlet activeElementDescriptor = {\n  get() {\n    return mixinImpl.activeElementForNode(this);\n  }\n}\n\nlet ActiveElementMixin = {};\nObject.defineProperties(ActiveElementMixin, {\n  activeElement: activeElementDescriptor\n});\n\nlet UnderActiveElementMixin = {};\nObject.defineProperties(UnderActiveElementMixin, {\n  _activeElement: activeElementDescriptor\n});\n\nexport let Mixins = {\n\n  Node: utils.extendAll({__patched: 'Node'}, NodeMixin),\n\n  Fragment: utils.extendAll({__patched: 'Fragment'},\n    NodeMixin, FragmentMixin, ActiveElementMixin),\n\n  Element: utils.extendAll({__patched: 'Element'},\n    NodeMixin, FragmentMixin, ElementMixin, ActiveElementMixin),\n\n  // Note: activeElement cannot be patched on document!\n  Document: utils.extendAll({__patched: 'Document'},\n    NodeMixin, FragmentMixin, ElementMixin, UnderActiveElementMixin)\n\n};\n\nexport let getRootNode = function(node) {\n  return mixinImpl.getRootNode(node);\n}\n\nexport function filterMutations(mutations, target) {\n  const targetRootNode = getRootNode(target);\n  return mutations.filter(function(mutation) {\n    const mutationInScope = (targetRootNode === getRootNode(mutation.target));\n    if (mutationInScope && mutation.addedNodes) {\n      let nodes = Array.from(mutation.addedNodes).filter(function(n) {\n        return (targetRootNode === getRootNode(n));\n      });\n      Object.defineProperty(mutation, 'addedNodes', {\n        value: nodes,\n        configurable: true\n      });\n    }\n    return mutationInScope &&\n      (!mutation.addedNodes || mutation.addedNodes.length);\n  });\n}\n\n// const promise = Promise.resolve();\n\nclass AsyncObserver {\n\n  constructor() {\n    this._scheduled = false;\n    this.addedNodes = [];\n    this.removedNodes = [];\n    this.callbacks = new Set();\n  }\n\n  schedule() {\n    if (!this._scheduled) {\n      this._scheduled = true;\n      utils.promish.then(() => {\n        this.flush();\n      });\n    }\n  }\n\n  flush() {\n    if (this._scheduled) {\n      this._scheduled = false;\n      let mutations = this.takeRecords();\n      if (mutations.length) {\n        this.callbacks.forEach(function(cb) {\n          cb(mutations);\n        });\n      }\n    }\n  }\n\n  takeRecords() {\n    if (this.addedNodes.length || this.removedNodes.length) {\n      let mutations = [{\n        addedNodes: this.addedNodes,\n        removedNodes: this.removedNodes\n      }];\n      this.addedNodes = [];\n      this.removedNodes = [];\n      return mutations;\n    }\n    return [];\n  }\n\n}\n\n// TODO(sorvell): consider instead polyfilling MutationObserver\n// directly so that users do not have to fork their code.\n// Supporting the entire api may be challenging: e.g. filtering out\n// removed nodes in the wrong scope and seeing non-distributing\n// subtree child mutations.\nexport let observeChildren = function(node, callback) {\n  utils.common.patchNode(node);\n  if (!node.__dom.observer) {\n    node.__dom.observer = new AsyncObserver();\n  }\n  node.__dom.observer.callbacks.add(callback);\n  let observer = node.__dom.observer;\n  return {\n    _callback: callback,\n    _observer: observer,\n    _node: node,\n    takeRecords() {\n      return observer.takeRecords()\n    }\n  };\n}\n\nexport let unobserveChildren = function(handle) {\n  let observer = handle && handle._observer;\n  if (observer) {\n    observer.callbacks.delete(handle._callback);\n    if (!observer.callbacks.size) {\n      handle._node.__dom.observer = null;\n    }\n  }\n}","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/**\n * Patches elements that interacts with ShadyDOM\n * such that tree traversal and mutation apis act like they would under\n * ShadowDOM.\n *\n * This import enables seemless interaction with ShadyDOM powered\n * custom elements, enabling better interoperation with 3rd party code,\n * libraries, and frameworks that use DOM tree manipulation apis.\n */\n\n'use strict';\nimport {tree} from './tree'\nimport * as utils from './utils'\nimport {Mixins} from './element-mixin'\n\nexport let patchedCount = 0;\n\nlet log = false;\n\nlet patchImpl = {\n\n  canPatchNode: function(node) {\n    switch (node) {\n      case document.head:\n      case document.documentElement:\n        return false;\n      default:\n        return true;\n    }\n  },\n\n  hasPrototypeDescriptors: Boolean(Object.getOwnPropertyDescriptor(\n    window.Node.prototype, 'textContent')),\n\n  patch: function(node) {\n    patchedCount++;\n    log && window.console.warn('patch node', node);\n    if (this.hasPrototypeDescriptors) {\n      utils.patchPrototype(node, this.mixinForObject(node));\n    } else {\n      window.console.warn('Patching instance rather than prototype', node);\n      utils.extend(node, this.mixinForNode(node));\n    }\n  },\n\n  mixinForObject: function(obj) {\n    switch (obj.nodeType) {\n      case Node.ELEMENT_NODE:\n        return Mixins.Element;\n      case Node.DOCUMENT_FRAGMENT_NODE:\n        return Mixins.Fragment;\n      case Node.DOCUMENT_NODE:\n        return Mixins.Document;\n      case Node.TEXT_NODE:\n      case Node.COMMENT_NODE:\n        return Mixins.Node;\n    }\n  },\n\n  unpatch: function(obj) {\n    if (obj.__sourceProto) {\n      obj.__proto__ = obj.__sourceProto;\n\n    }\n    // TODO(sorvell): implement unpatching for non-proto patchable browsers\n  }\n\n};\n\nexport function patchNode(node) {\n  if (!utils.settings.inUse) {\n    return;\n  }\n  if (!isNodePatched(node) && patchImpl.canPatchNode(node)) {\n    tree.saveChildNodes(node);\n    patchImpl.patch(node);\n  }\n}\n\nexport function unpatchNode(node) {\n  patchImpl.unpatch(node);\n}\n\nexport function isNodePatched(node) {\n  return Boolean(node.__patched);\n}\n\n// TODO(sorvell): fake export\nutils.common.patchNode = patchNode;\nutils.common.isNodePatched = isNodePatched;","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n'use strict';\n\nimport * as utils from './utils'\n\nlet origAddEventListener = Element.prototype.addEventListener;\nlet origRemoveEventListener = Element.prototype.removeEventListener;\n\n// https://github.com/w3c/webcomponents/issues/513#issuecomment-224183937\nlet alwaysComposed = {\n  blur: true,\n  focus: true,\n  focusin: true,\n  focusout: true,\n  click: true,\n  dblclick: true,\n  mousedown: true,\n  mouseenter: true,\n  mouseleave: true,\n  mousemove: true,\n  mouseout: true,\n  mouseover: true,\n  mouseup: true,\n  wheel: true,\n  beforeinput: true,\n  input: true,\n  keydown: true,\n  keyup: true,\n  compositionstart: true,\n  compositionupdate: true,\n  compositionend: true,\n  touchstart: true,\n  touchend: true,\n  touchmove: true,\n  touchcancel: true,\n  pointerover: true,\n  pointerenter: true,\n  pointerdown: true,\n  pointermove: true,\n  pointerup: true,\n  pointercancel: true,\n  pointerout: true,\n  pointerleave: true,\n  gotpointercapture: true,\n  lostpointercapture: true,\n  dragstart: true,\n  drag: true,\n  dragenter: true,\n  dragleave: true,\n  dragover: true,\n  drop: true,\n  dragend: true,\n  DOMActivate: true,\n  DOMFocusIn: true,\n  DOMFocusOut: true,\n  keypress: true\n};\n\nfunction pathComposer(startNode, composed) {\n  let composedPath = [];\n  let current = startNode;\n  let startRoot = startNode === window ? window : startNode.getRootNode();\n  while (current) {\n    composedPath.push(current);\n    if (current.assignedSlot) {\n      current = current.assignedSlot;\n    } else if (current.nodeType === Node.DOCUMENT_FRAGMENT_NODE && current.host && (composed || current !== startRoot)) {\n      current = current.host;\n    } else {\n      current = current.parentNode;\n    }\n  }\n  // event composedPath includes window when startNode's ownerRoot is document\n  if (composedPath[composedPath.length - 1] === document) {\n    composedPath.push(window);\n  }\n  return composedPath;\n}\n\nfunction retarget(refNode, path) {\n  if (!utils.isShadyRoot) {\n    return refNode;\n  }\n  // If ANCESTOR's root is not a shadow root or ANCESTOR's root is BASE's\n  // shadow-including inclusive ancestor, return ANCESTOR.\n  let refNodePath = pathComposer(refNode, true);\n  let p$ = path;\n  for (let i=0, ancestor, lastRoot, root, rootIdx; i < p$.length; i++) {\n    ancestor = p$[i];\n    root = ancestor === window ? window : ancestor.getRootNode();\n    if (root !== lastRoot) {\n      rootIdx = refNodePath.indexOf(root);\n      lastRoot = root;\n    }\n    if (!utils.isShadyRoot(root) || rootIdx > -1) {\n      return ancestor;\n    }\n  }\n}\n\nlet EventMixin = {\n\n  __patched: 'Event',\n\n  get composed() {\n    if (this.isTrusted && this.__composed === undefined) {\n      this.__composed = alwaysComposed[this.type];\n    }\n    return this.__composed || false;\n  },\n\n  composedPath() {\n    if (!this.__composedPath) {\n      this.__composedPath = pathComposer(this.__target, this.composed);\n    }\n    return this.__composedPath;\n  },\n\n  get target() {\n    return retarget(this.currentTarget, this.composedPath());\n  },\n\n  // http://w3c.github.io/webcomponents/spec/shadow/#event-relatedtarget-retargeting\n  get relatedTarget() {\n    if (!this.__relatedTarget) {\n      return null;\n    }\n    if (!this.__relatedTargetComposedPath) {\n      this.__relatedTargetComposedPath = pathComposer(this.__relatedTarget, true);\n    }\n    // find the deepest node in relatedTarget composed path that is in the same root with the currentTarget\n    return retarget(this.currentTarget, this.__relatedTargetComposedPath);\n  },\n  stopPropagation() {\n    Event.prototype.stopPropagation.call(this);\n    this.__propagationStopped = true;\n  },\n  stopImmediatePropagation() {\n    Event.prototype.stopImmediatePropagation.call(this);\n    this.__immediatePropagationStopped = true;\n    this.__propagationStopped = true;\n  }\n\n};\n\nfunction mixinComposedFlag(Base) {\n  // NOTE: avoiding use of `class` here so that transpiled output does not\n  // try to do `Base.call` with a dom construtor.\n  let klazz = function(type, options) {\n    let event = new Base(type, options);\n    event.__composed = options && Boolean(options.composed);\n    return event;\n  }\n  // put constructor properties on subclass\n  utils.mixin(klazz, Base);\n  klazz.prototype = Base.prototype;\n  return klazz;\n}\n\nlet nonBubblingEventsToRetarget = {\n  focus: true,\n  blur: true\n};\n\nfunction fireHandlers(event, node, phase) {\n  let hs = node.__handlers && node.__handlers[event.type] &&\n    node.__handlers[event.type][phase];\n  if (hs) {\n    for (let i = 0, fn; (fn = hs[i]); i++) {\n      fn.call(node, event);\n      if (event.__immediatePropagationStopped) {\n        return;\n      }\n    }\n  }\n}\n\nfunction retargetNonBubblingEvent(e) {\n  let path = e.composedPath();\n  let node;\n  // override `currentTarget` to let patched `target` calculate correctly\n  Object.defineProperty(e, 'currentTarget', {\n    get: function() {\n      return node;\n    },\n    configurable: true\n  });\n  for (let i = path.length - 1; i >= 0; i--) {\n    node = path[i];\n    // capture phase fires all capture handlers\n    fireHandlers(e, node, 'capture');\n    if (e.__propagationStopped) {\n      return;\n    }\n  }\n\n  // set the event phase to `AT_TARGET` as in spec\n  Object.defineProperty(e, 'eventPhase', {value: Event.AT_TARGET});\n\n  // the event only needs to be fired when owner roots change when iterating the event path\n  // keep track of the last seen owner root\n  let lastFiredRoot;\n  for (let i = 0; i < path.length; i++) {\n    node = path[i];\n    if (i === 0 || (node.shadowRoot && node.shadowRoot === lastFiredRoot)) {\n      fireHandlers(e, node, 'bubble');\n      // don't bother with window, it doesn't have `getRootNode` and will be last in the path anyway\n      if (node !== window) {\n        lastFiredRoot = node.getRootNode();\n      }\n      if (e.__propagationStopped) {\n        return;\n      }\n    }\n  }\n}\n\nexport function addEventListener(type, fn, optionsOrCapture) {\n  if (!fn) {\n    return;\n  }\n\n  // The callback `fn` might be used for multiple nodes/events. Since we generate\n  // a wrapper function, we need to keep track of it when we remove the listener.\n  // It's more efficient to store the node/type/options information as Array in\n  // `fn` itself rather than the node (we assume that the same callback is used\n  // for few nodes at most, whereas a node will likely have many event listeners).\n  // NOTE(valdrin) invoking external functions is costly, inline has better perf.\n  let capture, once, passive;\n  if (typeof optionsOrCapture === 'object') {\n    capture = Boolean(optionsOrCapture.capture);\n    once = Boolean(optionsOrCapture.once);\n    passive = Boolean(optionsOrCapture.passive);\n  } else {\n    capture = Boolean(optionsOrCapture);\n    once = false;\n    passive = false;\n  }\n  if (fn.__eventWrappers) {\n    // Stop if the wrapper function has already been created.\n    for (let i = 0; i < fn.__eventWrappers.length; i++) {\n      if (fn.__eventWrappers[i].node === this &&\n          fn.__eventWrappers[i].type === type &&\n          fn.__eventWrappers[i].capture === capture &&\n          fn.__eventWrappers[i].once === once &&\n          fn.__eventWrappers[i].passive === passive) {\n        return;\n      }\n    }\n  } else {\n    fn.__eventWrappers = [];\n  }\n\n  const wrapperFn = function(e) {\n    // Support `once` option.\n    if (once) {\n      this.removeEventListener(type, fn, optionsOrCapture);\n    }\n    if (!e.__target) {\n      e.__target = e.target;\n      e.__relatedTarget = e.relatedTarget;\n      utils.patchPrototype(e, EventMixin);\n    }\n    // There are two critera that should stop events from firing on this node\n    // 1. the event is not composed and the current node is not in the same root as the target\n    // 2. when bubbling, if after retargeting, relatedTarget and target point to the same node\n    if (e.composed || e.composedPath().indexOf(this) > -1) {\n      if (e.eventPhase === Event.BUBBLING_PHASE) {\n        if (e.target === e.relatedTarget) {\n          e.stopImmediatePropagation();\n          return;\n        }\n      }\n      return fn(e);\n    }\n  };\n  // Store the wrapper information.\n  fn.__eventWrappers.push({\n    node: this,\n    type: type,\n    capture: capture,\n    once: once,\n    passive: passive,\n    wrapperFn: wrapperFn\n  });\n\n  if (nonBubblingEventsToRetarget[type]) {\n    this.__handlers = this.__handlers || {};\n    this.__handlers[type] = this.__handlers[type] || {capture: [], bubble: []};\n    this.__handlers[type][capture ? 'capture' : 'bubble'].push(wrapperFn);\n  } else {\n    origAddEventListener.call(this, type, wrapperFn, optionsOrCapture);\n  }\n}\n\nexport function removeEventListener(type, fn, optionsOrCapture) {\n  if (!fn) {\n    return;\n  }\n\n  // NOTE(valdrin) invoking external functions is costly, inline has better perf.\n  let capture, once, passive;\n  if (typeof optionsOrCapture === 'object') {\n    capture = Boolean(optionsOrCapture.capture);\n    once = Boolean(optionsOrCapture.once);\n    passive = Boolean(optionsOrCapture.passive);\n  } else {\n    capture = Boolean(optionsOrCapture);\n    once = false;\n    passive = false;\n  }\n  // Search the wrapped function.\n  let wrapperFn = undefined;\n  if (fn.__eventWrappers) {\n    for (let i = 0; i < fn.__eventWrappers.length; i++) {\n      if (fn.__eventWrappers[i].node === this &&\n          fn.__eventWrappers[i].type === type &&\n          fn.__eventWrappers[i].capture === capture &&\n          fn.__eventWrappers[i].once === once &&\n          fn.__eventWrappers[i].passive === passive) {\n        wrapperFn = fn.__eventWrappers.splice(i, 1)[0].wrapperFn;\n        // Cleanup.\n        if (!fn.__eventWrappers.length) {\n          fn.__eventWrappers = undefined;\n        }\n        break;\n      }\n    }\n  }\n\n  origRemoveEventListener.call(this, type, wrapperFn || fn, optionsOrCapture);\n  if (wrapperFn && nonBubblingEventsToRetarget[type] &&\n      this.__handlers && this.__handlers[type]) {\n    const arr = this.__handlers[type][capture ? 'capture' : 'bubble'];\n    const idx = arr.indexOf(wrapperFn);\n    if (idx > -1) {\n      arr.splice(idx, 1);\n    }\n  }\n}\n\nexport function activateFocusEventOverrides() {\n  for (let ev in nonBubblingEventsToRetarget) {\n    window.addEventListener(ev, function(e) {\n      if (!e.__target) {\n        e.__target = e.target;\n        e.__relatedTarget = e.relatedTarget;\n        utils.patchPrototype(e, EventMixin);\n        retargetNonBubblingEvent(e);\n        e.stopImmediatePropagation();\n      }\n    }, true);\n  }\n}\n\nexport let OriginalEvent = Event;\nexport let PatchedEvent = mixinComposedFlag(Event);\nexport let PatchedCustomEvent = mixinComposedFlag(CustomEvent);\nexport let PatchedMouseEvent = mixinComposedFlag(MouseEvent);\n","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n'use strict';\n\nimport {tree} from './tree'\n\n// NOTE: normalize event contruction where necessary (IE11)\nlet NormalizedEvent = typeof Event === 'function' ? Event :\n  function(inType, params) {\n    params = params || {};\n    var e = document.createEvent('Event');\n    e.initEvent(inType, Boolean(params.bubbles), Boolean(params.cancelable));\n    return e;\n  };\n\nexport default class {\n\n  constructor(root) {\n    this.root = root;\n    this.insertionPointTag = 'slot';\n  }\n\n  getInsertionPoints() {\n    return this.root.querySelectorAll(this.insertionPointTag);\n  }\n\n  hasInsertionPoint() {\n    return Boolean(this.root._insertionPoints &&\n      this.root._insertionPoints.length);\n  }\n\n  isInsertionPoint(node) {\n    return node.localName && node.localName == this.insertionPointTag;\n  }\n\n  distribute() {\n    if (this.hasInsertionPoint()) {\n      return this.distributePool(this.root, this.collectPool());\n    }\n    return [];\n  }\n\n  // Gather the pool of nodes that should be distributed. We will combine\n  // these with the \"content root\" to arrive at the composed tree.\n  collectPool() {\n    return tree.arrayCopy(\n      tree.Logical.getChildNodes(this.root.host));\n  }\n\n  // perform \"logical\" distribution; note, no actual dom is moved here,\n  // instead elements are distributed into storage\n  // array where applicable.\n  distributePool(node, pool) {\n    let dirtyRoots = [];\n    let p$ = this.root._insertionPoints;\n    for (let i=0, l=p$.length, p; (i<l) && (p=p$[i]); i++) {\n      this.distributeInsertionPoint(p, pool);\n      // provoke redistribution on insertion point parents\n      // must do this on all candidate hosts since distribution in this\n      // scope invalidates their distribution.\n      // only get logical parent.\n      let parent = tree.Logical.getParentNode(p);\n      if (parent && parent.shadyRoot &&\n          this.hasInsertionPoint(parent.shadyRoot)) {\n        dirtyRoots.push(parent.shadyRoot);\n      }\n    }\n    for (let i=0; i < pool.length; i++) {\n      let p = pool[i];\n      if (p) {\n        p._assignedSlot = undefined;\n        // remove undistributed elements from physical dom.\n        let parent = tree.Composed.getParentNode(p);\n        if (parent) {\n          tree.Composed.removeChild(parent, p);\n        }\n      }\n    }\n    return dirtyRoots;\n  }\n\n  distributeInsertionPoint(insertionPoint, pool) {\n    let prevAssignedNodes = insertionPoint._assignedNodes;\n    if (prevAssignedNodes) {\n      this.clearAssignedSlots(insertionPoint, true);\n    }\n    insertionPoint._assignedNodes = [];\n    let needsSlotChange = false;\n    // distribute nodes from the pool that this selector matches\n    let anyDistributed = false;\n    for (let i=0, l=pool.length, node; i < l; i++) {\n      node=pool[i];\n      // skip nodes that were already used\n      if (!node) {\n        continue;\n      }\n      // distribute this node if it matches\n      if (this.matchesInsertionPoint(node, insertionPoint)) {\n        if (node.__prevAssignedSlot != insertionPoint) {\n          needsSlotChange = true;\n        }\n        this.distributeNodeInto(node, insertionPoint)\n        // remove this node from the pool\n        pool[i] = undefined;\n        // since at least one node matched, we won't need fallback content\n        anyDistributed = true;\n      }\n    }\n    // Fallback content if nothing was distributed here\n    if (!anyDistributed) {\n      let children = tree.Logical.getChildNodes(insertionPoint);\n      for (let j = 0, node; j < children.length; j++) {\n        node = children[j];\n        if (node.__prevAssignedSlot != insertionPoint) {\n          needsSlotChange = true;\n        }\n        this.distributeNodeInto(node, insertionPoint);\n      }\n    }\n    // we're already dirty if a node was newly added to the slot\n    // and we're also dirty if the assigned count decreased.\n    if (prevAssignedNodes) {\n      // TODO(sorvell): the tracking of previously assigned slots\n      // could instead by done with a Set and then we could\n      // avoid needing to iterate here to clear the info.\n      for (let i=0; i < prevAssignedNodes.length; i++) {\n        prevAssignedNodes[i].__prevAssignedSlot = null;\n      }\n      if (insertionPoint._assignedNodes.length < prevAssignedNodes.length) {\n        needsSlotChange = true;\n      }\n    }\n    this.setDistributedNodesOnInsertionPoint(insertionPoint);\n    if (needsSlotChange) {\n      this._fireSlotChange(insertionPoint);\n    }\n  }\n\n  clearAssignedSlots(slot, savePrevious) {\n    let n$ = slot._assignedNodes;\n    if (n$) {\n      for (let i=0; i < n$.length; i++) {\n        let n = n$[i];\n        if (savePrevious) {\n          n.__prevAssignedSlot = n._assignedSlot;\n        }\n        // only clear if it was previously set to this slot;\n        // this helps ensure that if the node has otherwise been distributed\n        // ignore it.\n        if (n._assignedSlot === slot) {\n          n._assignedSlot = null;\n        }\n      }\n    }\n  }\n\n  matchesInsertionPoint(node, insertionPoint) {\n    let slotName = insertionPoint.getAttribute('name');\n    slotName = slotName ? slotName.trim() : '';\n    let slot = node.getAttribute && node.getAttribute('slot');\n    slot = slot ? slot.trim() : '';\n    return (slot == slotName);\n  }\n\n  distributeNodeInto(child, insertionPoint) {\n    insertionPoint._assignedNodes.push(child);\n    child._assignedSlot = insertionPoint;\n  }\n\n  setDistributedNodesOnInsertionPoint(insertionPoint) {\n    let n$ = insertionPoint._assignedNodes;\n    insertionPoint._distributedNodes = [];\n    for (let i=0, n; (i<n$.length) && (n=n$[i]) ; i++) {\n      if (this.isInsertionPoint(n)) {\n        let d$ = n._distributedNodes;\n        if (d$) {\n          for (let j=0; j < d$.length; j++) {\n            insertionPoint._distributedNodes.push(d$[j]);\n          }\n        }\n      } else {\n        insertionPoint._distributedNodes.push(n$[i]);\n      }\n    }\n  }\n\n  _fireSlotChange(insertionPoint) {\n    // NOTE: cannot bubble correctly here so not setting bubbles: true\n    // Safari tech preview does not bubble but chrome does\n    // Spec says it bubbles (https://dom.spec.whatwg.org/#mutation-observers)\n    insertionPoint.dispatchEvent(new NormalizedEvent('slotchange'));\n    if (insertionPoint._assignedSlot) {\n      this._fireSlotChange(insertionPoint._assignedSlot);\n    }\n  }\n\n  isFinalDestination(insertionPoint) {\n    return !(insertionPoint._assignedSlot);\n  }\n\n}","/**\n@license\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n*/\n\n/**\n * Patches elements that interacts with ShadyDOM\n * such that tree traversal and mutation apis act like they would under\n * ShadowDOM.\n *\n * This import enables seemless interaction with ShadyDOM powered\n * custom elements, enabling better interoperation with 3rd party code,\n * libraries, and frameworks that use DOM tree manipulation apis.\n */\n\n'use strict';\nimport * as utils from './utils'\nimport {ShadyRoot, flush, enqueue} from './shady'\nimport * as patch from './patch'\nimport {getRootNode, filterMutations, observeChildren, unobserveChildren}\n  from './element-mixin'\nimport * as events from './event-mixin'\nimport {tree, getNativeProperty} from './tree'\n\nif (utils.settings.inUse) {\n\n  window.ShadyDOM = {\n    tree: tree,\n    getNativeProperty: getNativeProperty,\n    patch: patch.patchNode,\n    isPatched: patch.isNodePatched,\n    unpatch: patch.unpatchNode,\n    isShadyRoot: utils.isShadyRoot,\n    enqueue: enqueue,\n    flush: flush,\n    inUse: utils.settings.inUse,\n    filterMutations: filterMutations,\n    observeChildren: observeChildren,\n    unobserveChildren: unobserveChildren\n  };\n\n  let createRootAndEnsurePatched = function(node) {\n    // TODO(sorvell): need to ensure ancestors are patched but this introduces\n    // a timing problem with gathering composed children.\n    // (1) currently the child list is crawled and patched when patching occurs\n    // (this needs to change)\n    // (2) we can only patch when an element has received its parsed children\n    // because we cannot detect them when inserted by parser.\n    // let ancestor = node;\n    // while (ancestor) {\n    //   patchNode(ancestor);\n    //   ancestor = ancestor.parentNode || ancestor.host;\n    // }\n    patch.patchNode(node);\n    let root = new ShadyRoot(node);\n    patch.patchNode(root);\n    return root;\n  }\n\n  Element.prototype.attachShadow = function() {\n    return createRootAndEnsurePatched(this);\n  }\n\n  Node.prototype.addEventListener = events.addEventListener;\n  Node.prototype.removeEventListener = events.removeEventListener;\n  Event = events.PatchedEvent;\n  CustomEvent = events.PatchedCustomEvent;\n  MouseEvent = events.PatchedMouseEvent;\n  events.activateFocusEventOverrides();\n\n  Object.defineProperty(Node.prototype, 'isConnected', {\n    get() {\n      return document.documentElement.contains(this);\n    },\n    configurable: true\n  });\n\n  Node.prototype.getRootNode = function(options) {\n    return getRootNode(this, options);\n  }\n\n  Object.defineProperty(Element.prototype, 'slot', {\n    get() {\n      return this.getAttribute('slot');\n    },\n    set(value) {\n      this.setAttribute('slot', value);\n    },\n    configurable: true\n  });\n\n  Object.defineProperty(Node.prototype, 'assignedSlot', {\n    get() {\n      return this._assignedSlot || null;\n    },\n    configurable: true\n  });\n\n  // TODO(sorvell): super experimental auto patching of document fragment\n  // via appendChild. This either needs to be expanded or contracted.\n  // DocumentFragment.prototype.appendChild = function(node) {\n  //   patchNode(this);\n  //   return this.appendChild(node);\n  // }\n\n}\n"]}