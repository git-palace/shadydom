{"version":3,"sources":[" [synthetic:base] "," [synthetic:util/defineproperty] "," [synthetic:util/global] "," [synthetic:util/polyfill] "," [synthetic:es6/object/setprototypeof] ","src/array-splice.js","src/utils.js","src/tree.js","src/distributor.js","src/innerHTML.js","src/element-mixin.js","src/shady.js","src/patch.js","src/event-mixin.js","src/env.js"],"names":["newSplice$$module$$src$array_splice","newSplice","index","removed","addedCount","EDIT_LEAVE","EDIT_UPDATE","EDIT_ADD","EDIT_DELETE","ArraySplice","calcEditDistances","current","currentStart","currentEnd","old","oldStart","oldEnd","rowCount","columnCount","distances","Array","i","j","equals","north","west","spliceOperationsFromEditDistances","length","edits","push","northWest","min","reverse","calcSplices","prefixCount","suffixCount","minLength","Math","sharedPrefix","sharedSuffix","splice","ops","undefined","splices","oldIndex","searchLength","index1","index2","count","calculateSplices","previous","currentValue","previousValue","calculateSplices$$module$$src$array_splice","module$$src$array_splice","settings","window","ShadyDOM","hasNativeShadowDOM","attachShadow","Element","prototype","inUse","force","isShadyRoot$$module$$src$utils","isShadyRoot","obj","__localName","p","matches","matchesSelector","mozMatchesSelector","msMatchesSelector","oMatchesSelector","webkitMatchesSelector","matchesSelector$$module$$src$utils","element","selector","call","copyOwnProperty$$module$$src$utils","copyOwnProperty","name","source","target","pd","Object","getOwnPropertyDescriptor","defineProperty","extend$$module$$src$utils","extend","n$","getOwnPropertyNames","n","extendAll$$module$$src$utils","extendAll","sources","mixin$$module$$src$utils","mixin","patchPrototype$$module$$src$utils","patchPrototype","proto","getPrototypeOf","hasOwnProperty","patchProto","create","__sourceProto","__patchProto","setPrototypeOf","unpatchPrototype$$module$$src$utils","unpatchPrototype","common","module$$src$utils","nativeInsertBefore","insertBefore","nativeAppendChild","appendChild","nativeRemoveChild","removeChild","tree","arrayCopyChildNodes","parent","copy","firstChild","nextSibling","arrayCopyChildren","firstElementChild","nextElementSibling","arrayCopy","a$","l","saveChildNodes","node","Logical","Composed","hasParentNode","saveComposedData","__dom","parentNode","hasChildNodes","childNodes","getChildNodes","_getChildNodes","getFirstChild","getNextSibling","getParentNode","getLastChild","lastChild","getPreviousSibling","previousSibling","getFirstElementChild","_getFirstElementChild","nodeType","Node","ELEMENT_NODE","getLastElementChild","_getLastElementChild","getNextElementSibling","_getNextElementSibling","getPreviousElementSibling","_getPreviousElementSibling","c$","patchNode","recordInsertBefore","container","ref_node","DOCUMENT_FRAGMENT_NODE","_linkNode","recordRemoveChild","$parentNode","$childNodes","__patched","$firstChild","$nextSibling","getComposedChildNodes","$lastChild","$previousSibling","lastElementChild","previousElementSibling","clearChildNodes","c","saveParentNode","newChild","refChild","_addChild","currentParent","_removeChild","isFrag","oldParent","descriptors","getNativeProperty$$module$$src$tree","getNativeProperty","property","HTMLElement","get","assertNative$$module$$src$tree","assertNative","tracked","native","console","warn","module$$src$tree","$jscompDefaultExport","constructor","root","insertionPointTag","getInsertionPoints","querySelectorAll","hasInsertionPoint","_insertionPoints","isInsertionPoint","localName","reset","children","host","resetChild","p$","resetInsertionPoint","child","_assignedSlot","insertionPoint","_distributedNodes","_assignedNodes","distribute","distributePool","collectPool","pool","dirtyRoots","distributeInsertionPoint","shadyRoot","anyDistributed","matchesInsertionPoint","distributeNodeInto","setDistributedNodesOnInsertionPoint","slotName","getAttribute","trim","slot","d$","isFinalDestination","rendered","ip$","__eventListenerCount","dispatchEvent","Event","cancelable","module$$src$distributor","default","escapeAttrRegExp","escapeDataRegExp","escapeReplace$$module$$src$innerHTML","escapeReplace","escapeAttr$$module$$src$innerHTML","escapeAttr","s","replace","escapeData$$module$$src$innerHTML","escapeData","makeSet$$module$$src$innerHTML","makeSet","arr","set","voidElements","plaintextParents","getOuterHTML$$module$$src$innerHTML","getOuterHTML","composed","tagName","attrs","attributes","attr","value","getInnerHTML","TEXT_NODE","data","COMMENT_NODE","error","Error","getInnerHTML$$module$$src$innerHTML","content","module$$src$innerHTML","mixinImpl","addNode","ownerRoot","ownerShadyRootForNode","__noInsertionPoint","_skipUpdateInsertionPoints","_maybeAddInsertionPoint","ipAdded","_addedNode","handled","_maybeDistribute","removeNode","logicalParent","distributed","maybeDistributeParent","_removeDistributedChildren","getInsertionPointTag","update","_removeOwnerShadyRoot","_removedNode","removeNodeFromParent","_hasCachedOwnerRoot","__ownerShadyRoot","getRootNode","document","contains","fragContent","querySelector","wrappedContent","hasContent","needsDist","_nodeNeedsDistribution","added","np","na","hostNeedsDist","_contains","dc$","assignedNodes","flatten","firstComposedNode","clearNode","maybeDistributeAttributeChange","query","matcher","halter","list","_queryElements","elements","_queryElement","result","activeElementForNode","active","activeElement","activeRoot","nativeCloneNode","cloneNode","nativeImportNode","Document","importNode","nativeSetAttribute","setAttribute","nativeRemoveAttribute","removeAttribute","NodeMixin","defineProperties","parentElement","configurable","assignedSlot","FragmentMixin","replaceChild","deep","nc","externalNode","doc","ownerDocument","isArray","filter","textContent","tc","cn","join","text","createTextNode","innerHTML","d","createElement","ElementMixin","options","shadowRoot","activeElementDescriptor","ActiveElementMixin","UnderActiveElementMixin","_activeElement","Mixins","Fragment","module$$src$element_mixin","ShadyRoot","frag","createDocumentFragment","__proto__","ShadyFragmentMixin","_init","ShadyMixin","_clean","_hasRendered","_distributor","distributionRoot","_findDistributionRoot","enqueue","render","_elementNeedsDistribution","updateInsertionPoints","compose","forceRender","i$","__insertionPoints","insertionPoints","_composeTree","_updateChildNodes","_composeNode","distributedNodes","distributedNode","next","DocumentFragment","customElements","CustomElements","flushList","scheduled","enqueue$$module$$src$shady","callback","Promise","resolve","then","flush","flush$$module$$src$shady","shift","takeRecords","module$$src$shady","patchedCount","log","patchImpl","canPatchNode","head","documentElement","hasPrototypeDescriptors","patch","mixinForObject","mixinForNode","DOCUMENT_NODE","unpatch","patchNode$$module$$src$patch","isNodePatched","unpatchNode$$module$$src$patch","unpatchNode","isNodePatched$$module$$src$patch","module$$src$patch","origAddEventListener","addEventListener","origRemoveEventListener","removeEventListener","alwaysComposed","blur","focus","focusin","focusout","click","dblclick","mousedown","mouseenter","mouseleave","mousemove","mouseout","mouseover","mouseup","wheel","beforeinput","input","keydown","keyup","compositionstart","compositionupdate","compositionend","touchstart","touchend","touchmove","touchcancel","pointerover","pointerenter","pointerdown","pointermove","pointerup","pointercancel","pointerout","pointerleave","gotpointercapture","lostpointercapture","dragstart","drag","dragenter","dragleave","dragover","drop","dragend","DOMActivate","DOMFocusIn","DOMFocusOut","keypress","pathComposer$$module$$src$event_mixin","pathComposer","startNode","composedPath","startRoot","retarget$$module$$src$event_mixin","retarget","refNode","path","refNodePath","ancestor","lastRoot","rootIdx","indexOf","getRootNode$$module$$src$event_mixin","EventMixin","isTrusted","__composed","type","__composedPath","__target","currentTarget","relatedTarget","__relatedTarget","__relatedTargetComposedPath","stopPropagation","__propagationStopped","stopImmediatePropagation","__immediatePropagationStopped","mixinComposedFlag$$module$$src$event_mixin","mixinComposedFlag","Base","klazz","event","nonBubblingEventsToRetarget","fireHandlers$$module$$src$event_mixin","fireHandlers","phase","hs","__handlers","fn","retargetNonBubblingEvent$$module$$src$event_mixin","retargetNonBubblingEvent","e","BUBBLING_PHASE","shouldCapture$$module$$src$event_mixin","shouldCapture","optionsOrCapture","capture","addEventListener$$module$$src$event_mixin","wrappedFn","eventPhase","__eventWrapper","bubble","removeEventListener$$module$$src$event_mixin","wrapper","idx","ev","OriginalEvent","PatchedEvent","PatchedCustomEvent","CustomEvent","PatchedMouseEvent","MouseEvent","module$$src$event_mixin","isPatched","createRootAndEnsurePatched","Element.prototype.attachShadow","Node.prototype.getRootNode"],"mappings":"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","file":"shadydom.min.js","sourcesContent":[null,null,null,null,null,"/**\r\n@license\r\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\r\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\r\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\r\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\r\nCode distributed by Google as part of the polymer project is also\r\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\r\n*/\r\n\r\n'use strict';\r\n\r\nfunction newSplice(index, removed, addedCount) {\r\n  return {\r\n    index: index,\r\n    removed: removed,\r\n    addedCount: addedCount\r\n  };\r\n}\r\n\r\nconst EDIT_LEAVE = 0;\r\nconst EDIT_UPDATE = 1;\r\nconst EDIT_ADD = 2;\r\nconst EDIT_DELETE = 3;\r\n\r\nlet ArraySplice = {\r\n\r\n  // Note: This function is *based* on the computation of the Levenshtein\r\n  // \"edit\" distance. The one change is that \"updates\" are treated as two\r\n  // edits - not one. With Array splices, an update is really a delete\r\n  // followed by an add. By retaining this, we optimize for \"keeping\" the\r\n  // maximum array items in the original array. For example:\r\n  //\r\n  //   'xxxx123' -> '123yyyy'\r\n  //\r\n  // With 1-edit updates, the shortest path would be just to update all seven\r\n  // characters. With 2-edit updates, we delete 4, leave 3, and add 4. This\r\n  // leaves the substring '123' intact.\r\n  calcEditDistances(current, currentStart, currentEnd,\r\n                              old, oldStart, oldEnd) {\r\n    // \"Deletion\" columns\r\n    let rowCount = oldEnd - oldStart + 1;\r\n    let columnCount = currentEnd - currentStart + 1;\r\n    let distances = new Array(rowCount);\r\n\r\n    // \"Addition\" rows. Initialize null column.\r\n    for (let i = 0; i < rowCount; i++) {\r\n      distances[i] = new Array(columnCount);\r\n      distances[i][0] = i;\r\n    }\r\n\r\n    // Initialize null row\r\n    for (let j = 0; j < columnCount; j++)\r\n      distances[0][j] = j;\r\n\r\n    for (let i = 1; i < rowCount; i++) {\r\n      for (let j = 1; j < columnCount; j++) {\r\n        if (this.equals(current[currentStart + j - 1], old[oldStart + i - 1]))\r\n          distances[i][j] = distances[i - 1][j - 1];\r\n        else {\r\n          let north = distances[i - 1][j] + 1;\r\n          let west = distances[i][j - 1] + 1;\r\n          distances[i][j] = north < west ? north : west;\r\n        }\r\n      }\r\n    }\r\n\r\n    return distances;\r\n  },\r\n\r\n  // This starts at the final weight, and walks \"backward\" by finding\r\n  // the minimum previous weight recursively until the origin of the weight\r\n  // matrix.\r\n  spliceOperationsFromEditDistances(distances) {\r\n    let i = distances.length - 1;\r\n    let j = distances[0].length - 1;\r\n    let current = distances[i][j];\r\n    let edits = [];\r\n    while (i > 0 || j > 0) {\r\n      if (i == 0) {\r\n        edits.push(EDIT_ADD);\r\n        j--;\r\n        continue;\r\n      }\r\n      if (j == 0) {\r\n        edits.push(EDIT_DELETE);\r\n        i--;\r\n        continue;\r\n      }\r\n      let northWest = distances[i - 1][j - 1];\r\n      let west = distances[i - 1][j];\r\n      let north = distances[i][j - 1];\r\n\r\n      let min;\r\n      if (west < north)\r\n        min = west < northWest ? west : northWest;\r\n      else\r\n        min = north < northWest ? north : northWest;\r\n\r\n      if (min == northWest) {\r\n        if (northWest == current) {\r\n          edits.push(EDIT_LEAVE);\r\n        } else {\r\n          edits.push(EDIT_UPDATE);\r\n          current = northWest;\r\n        }\r\n        i--;\r\n        j--;\r\n      } else if (min == west) {\r\n        edits.push(EDIT_DELETE);\r\n        i--;\r\n        current = west;\r\n      } else {\r\n        edits.push(EDIT_ADD);\r\n        j--;\r\n        current = north;\r\n      }\r\n    }\r\n\r\n    edits.reverse();\r\n    return edits;\r\n  },\r\n\r\n  /**\r\n   * Splice Projection functions:\r\n   *\r\n   * A splice map is a representation of how a previous array of items\r\n   * was transformed into a new array of items. Conceptually it is a list of\r\n   * tuples of\r\n   *\r\n   *   <index, removed, addedCount>\r\n   *\r\n   * which are kept in ascending index order of. The tuple represents that at\r\n   * the |index|, |removed| sequence of items were removed, and counting forward\r\n   * from |index|, |addedCount| items were added.\r\n   */\r\n\r\n  /**\r\n   * Lacking individual splice mutation information, the minimal set of\r\n   * splices can be synthesized given the previous state and final state of an\r\n   * array. The basic approach is to calculate the edit distance matrix and\r\n   * choose the shortest path through it.\r\n   *\r\n   * Complexity: O(l * p)\r\n   *   l: The length of the current array\r\n   *   p: The length of the old array\r\n   */\r\n  calcSplices(current, currentStart, currentEnd,\r\n                        old, oldStart, oldEnd) {\r\n    let prefixCount = 0;\r\n    let suffixCount = 0;\r\n    let splice;\r\n\r\n    let minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);\r\n    if (currentStart == 0 && oldStart == 0)\r\n      prefixCount = this.sharedPrefix(current, old, minLength);\r\n\r\n    if (currentEnd == current.length && oldEnd == old.length)\r\n      suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);\r\n\r\n    currentStart += prefixCount;\r\n    oldStart += prefixCount;\r\n    currentEnd -= suffixCount;\r\n    oldEnd -= suffixCount;\r\n\r\n    if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)\r\n      return [];\r\n\r\n    if (currentStart == currentEnd) {\r\n      splice = newSplice(currentStart, [], 0);\r\n      while (oldStart < oldEnd)\r\n        splice.removed.push(old[oldStart++]);\r\n\r\n      return [ splice ];\r\n    } else if (oldStart == oldEnd)\r\n      return [ newSplice(currentStart, [], currentEnd - currentStart) ];\r\n\r\n    let ops = this.spliceOperationsFromEditDistances(\r\n        this.calcEditDistances(current, currentStart, currentEnd,\r\n                               old, oldStart, oldEnd));\r\n\r\n    splice = undefined;\r\n    let splices = [];\r\n    let index = currentStart;\r\n    let oldIndex = oldStart;\r\n    for (let i = 0; i < ops.length; i++) {\r\n      switch(ops[i]) {\r\n        case EDIT_LEAVE:\r\n          if (splice) {\r\n            splices.push(splice);\r\n            splice = undefined;\r\n          }\r\n\r\n          index++;\r\n          oldIndex++;\r\n          break;\r\n        case EDIT_UPDATE:\r\n          if (!splice)\r\n            splice = newSplice(index, [], 0);\r\n\r\n          splice.addedCount++;\r\n          index++;\r\n\r\n          splice.removed.push(old[oldIndex]);\r\n          oldIndex++;\r\n          break;\r\n        case EDIT_ADD:\r\n          if (!splice)\r\n            splice = newSplice(index, [], 0);\r\n\r\n          splice.addedCount++;\r\n          index++;\r\n          break;\r\n        case EDIT_DELETE:\r\n          if (!splice)\r\n            splice = newSplice(index, [], 0);\r\n\r\n          splice.removed.push(old[oldIndex]);\r\n          oldIndex++;\r\n          break;\r\n      }\r\n    }\r\n\r\n    if (splice) {\r\n      splices.push(splice);\r\n    }\r\n    return splices;\r\n  },\r\n\r\n  sharedPrefix(current, old, searchLength) {\r\n    for (let i = 0; i < searchLength; i++)\r\n      if (!this.equals(current[i], old[i]))\r\n        return i;\r\n    return searchLength;\r\n  },\r\n\r\n  sharedSuffix(current, old, searchLength) {\r\n    let index1 = current.length;\r\n    let index2 = old.length;\r\n    let count = 0;\r\n    while (count < searchLength && this.equals(current[--index1], old[--index2]))\r\n      count++;\r\n\r\n    return count;\r\n  },\r\n\r\n  calculateSplices(current, previous) {\r\n    return this.calcSplices(current, 0, current.length, previous, 0,\r\n                            previous.length);\r\n  },\r\n\r\n  equals(currentValue, previousValue) {\r\n    return currentValue === previousValue;\r\n  }\r\n\r\n};\r\n\r\nexport let calculateSplices = (current, previous) =>\r\n  ArraySplice.calculateSplices(current, previous);\r\n","/**\r\n@license\r\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\r\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\r\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\r\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\r\nCode distributed by Google as part of the polymer project is also\r\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\r\n*/\r\n\r\n'use strict';\r\n\r\nexport let settings = window.ShadyDOM || {};\r\n\r\nsettings.hasNativeShadowDOM = Boolean(Element.prototype.attachShadow);\r\n\r\nsettings.inUse = settings.force || !settings.hasNativeShadowDOM;\r\n\r\nexport function isShadyRoot(obj) {\r\n  return Boolean(obj.__localName === 'ShadyRoot');\r\n}\r\n\r\nlet p = Element.prototype;\r\nlet matches = p.matches || p.matchesSelector ||\r\n  p.mozMatchesSelector || p.msMatchesSelector ||\r\n  p.oMatchesSelector || p.webkitMatchesSelector;\r\n\r\nexport function matchesSelector(element, selector) {\r\n  return matches.call(element, selector);\r\n}\r\n\r\nfunction copyOwnProperty(name, source, target) {\r\n  let pd = Object.getOwnPropertyDescriptor(source, name);\r\n  if (pd) {\r\n    Object.defineProperty(target, name, pd);\r\n  }\r\n}\r\n\r\nexport function extend(target, source) {\r\n  if (target && source) {\r\n    let n$ = Object.getOwnPropertyNames(source);\r\n    for (let i=0, n; (i<n$.length) && (n=n$[i]); i++) {\r\n      copyOwnProperty(n, source, target);\r\n    }\r\n  }\r\n  return target || source;\r\n}\r\n\r\nexport function extendAll(target, ...sources) {\r\n  for (let i=0; i < sources.length; i++) {\r\n    extend(target, sources[i]);\r\n  }\r\n  return target;\r\n}\r\n\r\nexport function mixin(target, source) {\r\n  for (var i in source) {\r\n    target[i] = source[i];\r\n  }\r\n  return target;\r\n}\r\n\r\nexport function patchPrototype(obj, mixin) {\r\n  let proto = Object.getPrototypeOf(obj);\r\n  if (!proto.hasOwnProperty('__patchProto')) {\r\n    let patchProto = Object.create(proto);\r\n    patchProto.__sourceProto = proto;\r\n    extend(patchProto, mixin);\r\n    proto.__patchProto = patchProto;\r\n  }\r\n  Object.setPrototypeOf(obj, proto.__patchProto);\r\n}\r\n\r\nexport function unpatchPrototype(obj) {\r\n  if (obj.__sourceProto) {\r\n    Object.setPrototypeOf(obj, obj.__sourceProto);\r\n  }\r\n}\r\n\r\nexport let common = {};","/**\r\n@license\r\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\r\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\r\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\r\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\r\nCode distributed by Google as part of the polymer project is also\r\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\r\n*/\r\n\r\n'use strict';\r\n\r\n// TODO(sorvell): circular (patch loads tree and tree loads patch)\r\n// for now this is stuck on `utils`\r\n//import {patchNode} from './patch'\r\nimport * as utils from './utils'\r\n\r\n// native add/remove\r\nlet nativeInsertBefore = Element.prototype.insertBefore;\r\nlet nativeAppendChild = Element.prototype.appendChild;\r\nlet nativeRemoveChild = Element.prototype.removeChild;\r\n\r\n/**\r\n * `tree` is a dom manipulation library used by ShadyDom to\r\n * manipulate composed and logical trees.\r\n */\r\nexport let tree = {\r\n\r\n  // sad but faster than slice...\r\n  arrayCopyChildNodes(parent) {\r\n    let copy=[], i=0;\r\n    for (let n=parent.firstChild; n; n=n.nextSibling) {\r\n      copy[i++] = n;\r\n    }\r\n    return copy;\r\n  },\r\n\r\n  arrayCopyChildren(parent) {\r\n    let copy=[], i=0;\r\n    for (let n=parent.firstElementChild; n; n=n.nextElementSibling) {\r\n      copy[i++] = n;\r\n    }\r\n    return copy;\r\n  },\r\n\r\n  arrayCopy(a$) {\r\n    let l = a$.length;\r\n    let copy = new Array(l);\r\n    for (let i=0; i < l; i++) {\r\n      copy[i] = a$[i];\r\n    }\r\n    return copy;\r\n  },\r\n\r\n  saveChildNodes(node) {\r\n    tree.Logical.saveChildNodes(node);\r\n    if (!tree.Composed.hasParentNode(node)) {\r\n      tree.Composed.saveComposedData(node);\r\n      //tree.Composed.saveParentNode(node);\r\n    }\r\n    tree.Composed.saveChildNodes(node);\r\n  }\r\n\r\n};\r\n\r\ntree.Logical = {\r\n\r\n  hasParentNode(node) {\r\n    return Boolean(node.__dom && node.__dom.parentNode);\r\n  },\r\n\r\n  hasChildNodes(node) {\r\n    return Boolean(node.__dom && node.__dom.childNodes !== undefined);\r\n  },\r\n\r\n  getChildNodes(node) {\r\n    // note: we're distinguishing here between undefined and false-y:\r\n    // hasChildNodes uses undefined check to see if this element has logical\r\n    // children; the false-y check indicates whether or not we should rebuild\r\n    // the cached childNodes array.\r\n    return this.hasChildNodes(node) ? this._getChildNodes(node) :\r\n      tree.Composed.getChildNodes(node);\r\n  },\r\n\r\n  _getChildNodes(node) {\r\n    if (!node.__dom.childNodes) {\r\n      node.__dom.childNodes = [];\r\n      for (let n=this.getFirstChild(node); n; n=this.getNextSibling(n)) {\r\n        node.__dom.childNodes.push(n);\r\n      }\r\n    }\r\n    return node.__dom.childNodes;\r\n  },\r\n\r\n  // NOTE: __dom can be created under 2 conditions: (1) an element has a\r\n  // logical tree, or (2) an element is in a logical tree. In case (1), the\r\n  // element will store firstChild/lastChild, and in case (2), the element\r\n  // will store parentNode, nextSibling, previousSibling. This means that\r\n  // the mere existence of __dom is not enough to know if the requested\r\n  // logical data is available and instead we do an explicit undefined check.\r\n  getParentNode(node) {\r\n    return node.__dom && node.__dom.parentNode !== undefined ?\r\n      node.__dom.parentNode : tree.Composed.getParentNode(node);\r\n  },\r\n\r\n  getFirstChild(node) {\r\n    return node.__dom && node.__dom.firstChild !== undefined ?\r\n      node.__dom.firstChild : tree.Composed.getFirstChild(node);\r\n  },\r\n\r\n  getLastChild(node) {\r\n    return node.__dom && node.__dom.lastChild  !== undefined ?\r\n      node.__dom.lastChild : tree.Composed.getLastChild(node);\r\n  },\r\n\r\n  getNextSibling(node) {\r\n    return node.__dom && node.__dom.nextSibling  !== undefined ?\r\n      node.__dom.nextSibling : tree.Composed.getNextSibling(node);\r\n  },\r\n\r\n  getPreviousSibling(node) {\r\n    return node.__dom && node.__dom.previousSibling  !== undefined ?\r\n      node.__dom.previousSibling : tree.Composed.getPreviousSibling(node);\r\n  },\r\n\r\n  getFirstElementChild(node) {\r\n    return node.__dom && node.__dom.firstChild !== undefined ?\r\n      this._getFirstElementChild(node) :\r\n      tree.Composed.getFirstElementChild(node);\r\n  },\r\n\r\n  _getFirstElementChild(node) {\r\n    let n = node.__dom.firstChild;\r\n    while (n && n.nodeType !== Node.ELEMENT_NODE) {\r\n      n = n.__dom.nextSibling;\r\n    }\r\n    return n;\r\n  },\r\n\r\n  getLastElementChild(node) {\r\n    return node.__dom && node.__dom.lastChild !== undefined ?\r\n      this._getLastElementChild(node) :\r\n      tree.Composed.getLastElementChild(node);\r\n  },\r\n\r\n  _getLastElementChild(node) {\r\n    let n = node.__dom.lastChild;\r\n    while (n && n.nodeType !== Node.ELEMENT_NODE) {\r\n      n = n.__dom.previousSibling;\r\n    }\r\n    return n;\r\n  },\r\n\r\n  getNextElementSibling(node) {\r\n    return node.__dom && node.__dom.nextSibling !== undefined ?\r\n      this._getNextElementSibling(node) :\r\n      tree.Composed.getNextElementSibling(node);\r\n  },\r\n\r\n  _getNextElementSibling(node) {\r\n    let n = node.__dom.nextSibling;\r\n    while (n && n.nodeType !== Node.ELEMENT_NODE) {\r\n      n = this.getNextSibling(n);\r\n    }\r\n    return n;\r\n  },\r\n\r\n  getPreviousElementSibling(node) {\r\n    return node.__dom && node.__dom.previousSibling !== undefined ?\r\n      this._getPreviousElementSibling(node) :\r\n      tree.Composed.getPreviousElementSibling(node);\r\n  },\r\n\r\n  _getPreviousElementSibling(node) {\r\n    let n = node.__dom.previousSibling;\r\n    while (n && n.nodeType !== Node.ELEMENT_NODE) {\r\n      n = this.getPreviousSibling(n);\r\n    }\r\n    return n;\r\n  },\r\n\r\n  // Capture the list of light children. It's important to do this before we\r\n  // start transforming the DOM into \"rendered\" state.\r\n  // Children may be added to this list dynamically. It will be treated as the\r\n  // source of truth for the light children of the element. This element's\r\n  // actual children will be treated as the rendered state once this function\r\n  // has been called.\r\n  saveChildNodes(node) {\r\n    if (!this.hasChildNodes(node)) {\r\n      node.__dom = node.__dom || {};\r\n      node.__dom.firstChild = node.firstChild;\r\n      node.__dom.lastChild = node.lastChild;\r\n      let c$ = node.__dom.childNodes = tree.arrayCopyChildNodes(node);\r\n      for (let i=0, n; (i<c$.length) && (n=c$[i]); i++) {\r\n        n.__dom = n.__dom || {};\r\n        n.__dom.parentNode = node;\r\n        n.__dom.nextSibling = c$[i+1] || null;\r\n        n.__dom.previousSibling = c$[i-1] || null;\r\n        utils.common.patchNode(n);\r\n      }\r\n    }\r\n  },\r\n\r\n  // TODO(sorvell): may need to patch saveChildNodes iff the tree has\r\n  // already been distributed.\r\n  // NOTE: ensure `node` is patched...\r\n  recordInsertBefore(node, container, ref_node) {\r\n    container.__dom.childNodes = null;\r\n    // handle document fragments\r\n    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\r\n      let c$ = tree.arrayCopyChildNodes(node);\r\n      for (let i=0; i < c$.length; i++) {\r\n        this._linkNode(c$[i], container, ref_node);\r\n      }\r\n      // cleanup logical dom in doc fragment.\r\n      node.__dom = node.__dom || {};\r\n      node.__dom.firstChild = node.__dom.lastChild = undefined;\r\n      node.__dom.childNodes = null;\r\n    } else {\r\n      this._linkNode(node, container, ref_node);\r\n    }\r\n  },\r\n\r\n  _linkNode(node, container, ref_node) {\r\n    utils.common.patchNode(node);\r\n    ref_node = ref_node || null;\r\n    node.__dom = node.__dom || {};\r\n    container.__dom = container.__dom || {};\r\n    if (ref_node) {\r\n      ref_node.__dom = ref_node.__dom || {};\r\n    }\r\n    // update ref_node.previousSibling <-> node\r\n    node.__dom.previousSibling = ref_node ? ref_node.__dom.previousSibling :\r\n      container.__dom.lastChild;\r\n    if (node.__dom.previousSibling) {\r\n      node.__dom.previousSibling.__dom.nextSibling = node;\r\n    }\r\n    // update node <-> ref_node\r\n    node.__dom.nextSibling = ref_node;\r\n    if (node.__dom.nextSibling) {\r\n      node.__dom.nextSibling.__dom.previousSibling = node;\r\n    }\r\n    // update node <-> container\r\n    node.__dom.parentNode = container;\r\n    if (ref_node) {\r\n      if (ref_node === container.__dom.firstChild) {\r\n        container.__dom.firstChild = node;\r\n      }\r\n    } else {\r\n      container.__dom.lastChild = node;\r\n      if (!container.__dom.firstChild) {\r\n        container.__dom.firstChild = node;\r\n      }\r\n    }\r\n    // remove caching of childNodes\r\n    container.__dom.childNodes = null;\r\n  },\r\n\r\n  recordRemoveChild(node, container) {\r\n    node.__dom = node.__dom || {};\r\n    container.__dom = container.__dom || {};\r\n    if (node === container.__dom.firstChild) {\r\n      container.__dom.firstChild = node.__dom.nextSibling;\r\n    }\r\n    if (node === container.__dom.lastChild) {\r\n      container.__dom.lastChild = node.__dom.previousSibling;\r\n    }\r\n    let p = node.__dom.previousSibling;\r\n    let n = node.__dom.nextSibling;\r\n    if (p) {\r\n      p.__dom = p.__dom || {};\r\n      p.__dom.nextSibling = n;\r\n    }\r\n    if (n) {\r\n      n.__dom = n.__dom || {};\r\n      n.__dom.previousSibling = p;\r\n    }\r\n    // When an element is removed, logical data is no longer tracked.\r\n    // Explicitly set `undefined` here to indicate this. This is disginguished\r\n    // from `null` which is set if info is null.\r\n    node.__dom.parentNode = node.__dom.previousSibling =\r\n      node.__dom.nextSibling = undefined;\r\n    // remove caching of childNodes\r\n    container.__dom.childNodes = null;\r\n  }\r\n\r\n}\r\n\r\n\r\n// TODO(sorvell): composed tree manipulation is made available\r\n// (1) to maninpulate the composed tree, and (2) to track changes\r\n// to the tree for optional patching pluggability.\r\ntree.Composed = {\r\n\r\n  hasParentNode(node) {\r\n    return Boolean(node.__dom && node.__dom.$parentNode !== undefined);\r\n  },\r\n\r\n  hasChildNodes(node) {\r\n    return Boolean(node.__dom && node.__dom.$childNodes !== undefined);\r\n  },\r\n\r\n  getChildNodes(node) {\r\n    return this.hasChildNodes(node) ? this._getChildNodes(node) :\r\n      (!node.__patched && tree.arrayCopy(node.childNodes));\r\n  },\r\n\r\n  _getChildNodes(node) {\r\n    if (!node.__dom.$childNodes) {\r\n      node.__dom.$childNodes = [];\r\n      for (let n=node.__dom.$firstChild; n; n=n.__dom.$nextSibling) {\r\n        node.__dom.$childNodes.push(n);\r\n      }\r\n    }\r\n    return node.__dom.$childNodes;\r\n  },\r\n\r\n  getComposedChildNodes(node) {\r\n    return node.__dom.$childNodes;\r\n  },\r\n\r\n  getParentNode(node) {\r\n    return this.hasParentNode(node) ? node.__dom.$parentNode :\r\n      (!node.__patched && node.parentNode);\r\n  },\r\n\r\n  getFirstChild(node) {\r\n    return node.__patched ? node.__dom.$firstChild : node.firstChild;\r\n  },\r\n\r\n  getLastChild(node) {\r\n    return node.__patched ? node.__dom.$lastChild : node.lastChild;\r\n  },\r\n\r\n  getNextSibling(node) {\r\n    return node.__patched ? node.__dom.$nextSibling : node.nextSibling;\r\n  },\r\n\r\n  getPreviousSibling(node) {\r\n    return node.__patched ? node.__dom.$previousSibling : node.previousSibling;\r\n  },\r\n\r\n  getFirstElementChild(node) {\r\n    return node.__patched ? this._getFirstElementChild(node) :\r\n      node.firstElementChild;\r\n  },\r\n\r\n  _getFirstElementChild(node) {\r\n    let n = node.__dom.$firstChild;\r\n    while (n && n.nodeType !== Node.ELEMENT_NODE) {\r\n      n = n.__dom.$nextSibling;\r\n    }\r\n    return n;\r\n  },\r\n\r\n  getLastElementChild(node) {\r\n    return node.__patched ? this._getLastElementChild(node) :\r\n      node.lastElementChild;\r\n  },\r\n\r\n  _getLastElementChild(node) {\r\n    let n = node.__dom.$lastChild;\r\n    while (n && n.nodeType !== Node.ELEMENT_NODE) {\r\n      n = n.__dom.$previousSibling;\r\n    }\r\n    return n;\r\n  },\r\n\r\n  getNextElementSibling(node) {\r\n    return node.__patched ? this._getNextElementSibling(node) :\r\n      node.nextElementSibling;\r\n  },\r\n\r\n  _getNextElementSibling(node) {\r\n    let n = node.__dom.$nextSibling;\r\n    while (n && n.nodeType !== Node.ELEMENT_NODE) {\r\n      n = this.getNextSibling(n);\r\n    }\r\n    return n;\r\n  },\r\n\r\n  getPreviousElementSibling(node) {\r\n    return node.__patched ? this._getPreviousElementSibling(node) :\r\n      node.previousElementSibling;\r\n  },\r\n\r\n  _getPreviousElementSibling(node) {\r\n    let n = node.__dom.$previousSibling;\r\n    while (n && n.nodeType !== Node.ELEMENT_NODE) {\r\n      n = this.getPreviousSibling(n);\r\n    }\r\n    return n;\r\n  },\r\n\r\n  saveChildNodes(node) {\r\n    if (!this.hasChildNodes(node)) {\r\n      node.__dom = node.__dom || {};\r\n      node.__dom.$firstChild = node.firstChild;\r\n      node.__dom.$lastChild = node.lastChild;\r\n      let c$ = node.__dom.$childNodes = tree.arrayCopyChildNodes(node);\r\n      for (let i=0, n; (i<c$.length) && (n=c$[i]); i++) {\r\n        this.saveComposedData(n);\r\n      }\r\n    }\r\n  },\r\n\r\n  saveComposedData(node) {\r\n    node.__dom = node.__dom || {};\r\n    if (node.__dom.$parentNode === undefined) {\r\n      node.__dom.$parentNode = node.parentNode;\r\n    }\r\n    if (node.__dom.$nextSibling === undefined) {\r\n      node.__dom.$nextSibling = node.nextSibling;\r\n    }\r\n    if (node.__dom.$previousSibling === undefined) {\r\n      node.__dom.$previousSibling = node.previousSibling;\r\n    }\r\n  },\r\n\r\n  recordInsertBefore(node, container, ref_node) {\r\n    container.__dom.$childNodes = null;\r\n    // handle document fragments\r\n    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\r\n      // TODO(sorvell): remember this for patching:\r\n      // the act of setting this info can affect patched nodes\r\n      // getters; therefore capture childNodes before patching.\r\n      for (let n=this.getFirstChild(node); n; n=this.getNextSibling(n)) {\r\n        this._linkNode(n, container, ref_node);\r\n      }\r\n    } else {\r\n      this._linkNode(node, container, ref_node);\r\n    }\r\n  },\r\n\r\n  _linkNode(node, container, ref_node) {\r\n    node.__dom = node.__dom || {};\r\n    container.__dom = container.__dom || {};\r\n    if (ref_node) {\r\n      ref_node.__dom = ref_node.__dom || {};\r\n    }\r\n    // update ref_node.previousSibling <-> node\r\n    node.__dom.$previousSibling = ref_node ? ref_node.__dom.$previousSibling :\r\n      container.__dom.$lastChild;\r\n    if (node.__dom.$previousSibling) {\r\n      node.__dom.$previousSibling.__dom.$nextSibling = node;\r\n    }\r\n    // update node <-> ref_node\r\n    node.__dom.$nextSibling = ref_node;\r\n    if (node.__dom.$nextSibling) {\r\n      node.__dom.$nextSibling.__dom.$previousSibling = node;\r\n    }\r\n    // update node <-> container\r\n    node.__dom.$parentNode = container;\r\n    if (ref_node) {\r\n      if (ref_node === container.__dom.$firstChild) {\r\n        container.__dom.$firstChild = node;\r\n      }\r\n    } else {\r\n      container.__dom.$lastChild = node;\r\n      if (!container.__dom.$firstChild) {\r\n        container.__dom.$firstChild = node;\r\n      }\r\n    }\r\n    // remove caching of childNodes\r\n    container.__dom.$childNodes = null;\r\n  },\r\n\r\n  recordRemoveChild(node, container) {\r\n    node.__dom = node.__dom || {};\r\n    container.__dom = container.__dom || {};\r\n    if (node === container.__dom.$firstChild) {\r\n      container.__dom.$firstChild = node.__dom.$nextSibling;\r\n    }\r\n    if (node === container.__dom.$lastChild) {\r\n      container.__dom.$lastChild = node.__dom.$previousSibling;\r\n    }\r\n    let p = node.__dom.$previousSibling;\r\n    let n = node.__dom.$nextSibling;\r\n    if (p) {\r\n      p.__dom = p.__dom || {};\r\n      p.__dom.$nextSibling = n;\r\n    }\r\n    if (n) {\r\n      n.__dom = n.__dom || {};\r\n      n.__dom.$previousSibling = p;\r\n    }\r\n    node.__dom.$parentNode = node.__dom.$previousSibling =\r\n      node.__dom.$nextSibling = null;\r\n    // remove caching of childNodes\r\n    container.__dom.$childNodes = null;\r\n  },\r\n\r\n  clearChildNodes(node) {\r\n    let c$ = this.getChildNodes(node);\r\n    for (let i=0, c; i < c$.length; i++) {\r\n      c = c$[i];\r\n      this.recordRemoveChild(c, node);\r\n      nativeRemoveChild.call(node, c)\r\n    }\r\n  },\r\n\r\n  saveParentNode(node) {\r\n    node.__dom = node.__dom || {};\r\n    node.__dom.$parentNode = node.parentNode;\r\n  },\r\n\r\n  insertBefore(parentNode, newChild, refChild) {\r\n    this.saveChildNodes(parentNode);\r\n    // remove from current location.\r\n    this._addChild(parentNode, newChild, refChild);\r\n    return nativeInsertBefore.call(parentNode, newChild, refChild || null);\r\n  },\r\n\r\n  appendChild(parentNode, newChild) {\r\n    this.saveChildNodes(parentNode);\r\n    this._addChild(parentNode, newChild);\r\n    return nativeAppendChild.call(parentNode, newChild);\r\n  },\r\n\r\n  removeChild(parentNode, node) {\r\n    let currentParent = this.getParentNode(node);\r\n    this.saveChildNodes(parentNode);\r\n    this._removeChild(parentNode, node);\r\n    if (currentParent === parentNode) {\r\n      return nativeRemoveChild.call(parentNode, node);\r\n    }\r\n  },\r\n\r\n  _addChild(parentNode, newChild, refChild) {\r\n    let isFrag = (newChild.nodeType === Node.DOCUMENT_FRAGMENT_NODE);\r\n    let oldParent = this.getParentNode(newChild);\r\n    if (oldParent) {\r\n      this._removeChild(oldParent, newChild);\r\n    }\r\n    if (isFrag) {\r\n      let c$ = this.getChildNodes(newChild);\r\n      for (let i=0; i < c$.length; i++) {\r\n        let c = c$[i];\r\n        // unlink document fragment children\r\n        this._removeChild(newChild, c);\r\n        this.recordInsertBefore(c, parentNode, refChild);\r\n      }\r\n    } else {\r\n      this.recordInsertBefore(newChild, parentNode, refChild);\r\n    }\r\n  },\r\n\r\n  _removeChild(parentNode, node) {\r\n    this.recordRemoveChild(node, parentNode);\r\n  }\r\n\r\n};\r\n\r\n// for testing...\r\nlet descriptors = {};\r\nexport function getNativeProperty(element, property) {\r\n  if (!descriptors[property]) {\r\n    descriptors[property] = Object.getOwnPropertyDescriptor(\r\n      HTMLElement.prototype, property) ||\r\n    Object.getOwnPropertyDescriptor(\r\n      Element.prototype, property) ||\r\n    Object.getOwnPropertyDescriptor(\r\n      Node.prototype, property);\r\n  }\r\n  return descriptors[property].get.call(element);\r\n}\r\n\r\n// for testing...\r\nfunction assertNative(element, property, tracked) {\r\n  let native = getNativeProperty(element, property);\r\n  if (native != tracked && element.__patched) {\r\n    window.console.warn('tracked', tracked, 'native', native);\r\n  }\r\n  return tracked;\r\n}","/**\r\n@license\r\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\r\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\r\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\r\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\r\nCode distributed by Google as part of the polymer project is also\r\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\r\n*/\r\n\r\n'use strict';\r\n\r\nimport {tree} from './tree'\r\n\r\nexport default class {\r\n\r\n  constructor(root) {\r\n    this.root = root;\r\n    this.insertionPointTag = 'slot';\r\n  }\r\n\r\n  getInsertionPoints() {\r\n    return this.root.querySelectorAll(this.insertionPointTag);\r\n  }\r\n\r\n  hasInsertionPoint() {\r\n    return Boolean(this.root._insertionPoints &&\r\n      this.root._insertionPoints.length);\r\n  }\r\n\r\n  isInsertionPoint(node) {\r\n    return node.localName && node.localName == this.insertionPointTag;\r\n  }\r\n\r\n  reset() {\r\n    // light children\r\n    let children = tree.Logical.getChildNodes(this.root.host);\r\n    for (let i = 0; i < children.length; i++) {\r\n      this.resetChild(children[i]);\r\n    }\r\n    // insertion points\r\n    let p$ = this.root._insertionPoints;\r\n    for (let j = 0; j < p$.length; j++) {\r\n      this.resetInsertionPoint(p$[j]);\r\n    }\r\n  }\r\n\r\n  resetChild(child) {\r\n    child._assignedSlot = undefined;\r\n  }\r\n\r\n  resetInsertionPoint(insertionPoint) {\r\n    insertionPoint._distributedNodes = [];\r\n    insertionPoint._assignedNodes = [];\r\n  }\r\n\r\n  distribute() {\r\n    if (this.hasInsertionPoint()) {\r\n      this.reset();\r\n      return this.distributePool(this.root, this.collectPool());\r\n    }\r\n    return [];\r\n  }\r\n\r\n  // Gather the pool of nodes that should be distributed. We will combine\r\n  // these with the \"content root\" to arrive at the composed tree.\r\n  collectPool() {\r\n    return tree.arrayCopy(\r\n      tree.Logical.getChildNodes(this.root.host));\r\n  }\r\n\r\n  // perform \"logical\" distribution; note, no actual dom is moved here,\r\n  // instead elements are distributed into a `content._distributedNodes`\r\n  // array where applicable.\r\n  distributePool(node, pool) {\r\n    let dirtyRoots = [];\r\n    let p$ = this.root._insertionPoints;\r\n    for (let i=0, l=p$.length, p; (i<l) && (p=p$[i]); i++) {\r\n      this.distributeInsertionPoint(p, pool);\r\n      // provoke redistribution on insertion point parents\r\n      // must do this on all candidate hosts since distribution in this\r\n      // scope invalidates their distribution.\r\n      // only get logical parent.\r\n      let parent = tree.Logical.getParentNode(p);\r\n      if (parent && parent.shadyRoot &&\r\n          this.hasInsertionPoint(parent.shadyRoot)) {\r\n        dirtyRoots.push(parent.shadyRoot);\r\n      }\r\n    }\r\n    return dirtyRoots;\r\n  }\r\n\r\n  distributeInsertionPoint(insertionPoint, pool) {\r\n    // distribute nodes from the pool that this selector matches\r\n    let anyDistributed = false;\r\n    for (let i=0, l=pool.length, node; i < l; i++) {\r\n      node=pool[i];\r\n      // skip nodes that were already used\r\n      if (!node) {\r\n        continue;\r\n      }\r\n      // distribute this node if it matches\r\n      if (this.matchesInsertionPoint(node, insertionPoint)) {\r\n        this.distributeNodeInto(node, insertionPoint);\r\n        // remove this node from the pool\r\n        pool[i] = undefined;\r\n        // since at least one node matched, we won't need fallback content\r\n        anyDistributed = true;\r\n      }\r\n    }\r\n    // Fallback content if nothing was distributed here\r\n    if (!anyDistributed) {\r\n      let children = tree.Logical.getChildNodes(insertionPoint);\r\n      for (let j = 0; j < children.length; j++) {\r\n        this.distributeNodeInto(children[j], insertionPoint);\r\n      }\r\n    }\r\n    this.setDistributedNodesOnInsertionPoint(insertionPoint);\r\n  }\r\n\r\n  matchesInsertionPoint(node, insertionPoint) {\r\n    let slotName = insertionPoint.getAttribute('name');\r\n    slotName = slotName ? slotName.trim() : '';\r\n    let slot = node.getAttribute && node.getAttribute('slot');\r\n    slot = slot ? slot.trim() : '';\r\n    return (slot == slotName);\r\n  }\r\n\r\n  distributeNodeInto(child, insertionPoint) {\r\n    insertionPoint._assignedNodes.push(child);\r\n    child._assignedSlot = insertionPoint;\r\n  }\r\n\r\n  setDistributedNodesOnInsertionPoint(insertionPoint) {\r\n    let n$ = insertionPoint._assignedNodes;\r\n    insertionPoint._distributedNodes = [];\r\n    for (let i=0, n; (i<n$.length) && (n=n$[i]) ; i++) {\r\n      if (this.isInsertionPoint(n)) {\r\n        let d$ = n._distributedNodes;\r\n        if (d$) {\r\n          for (let j=0; j < d$.length; j++) {\r\n            insertionPoint._distributedNodes.push(d$[j]);\r\n          }\r\n        }\r\n      } else {\r\n        insertionPoint._distributedNodes.push(n$[i]);\r\n      }\r\n    }\r\n  }\r\n\r\n  isFinalDestination(insertionPoint) {\r\n    return !(insertionPoint._assignedSlot);\r\n  }\r\n\r\n  rendered() {\r\n    let ip$ = this.root._insertionPoints;\r\n    for (let i=0, slot; i < ip$.length; i++) {\r\n      slot = ip$[i];\r\n      if (slot.__eventListenerCount) {\r\n        // NOTE: cannot bubble correctly here so not setting bubbles: true\r\n        slot.dispatchEvent(new Event('slotchange', { cancelable: true }));\r\n      }\r\n    }\r\n  }\r\n\r\n}","/**\r\n@license\r\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\r\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\r\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\r\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\r\nCode distributed by Google as part of the polymer project is also\r\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\r\n*/\r\n\r\n'use strict';\r\n\r\n// Cribbed from ShadowDOM polyfill\r\n// https://github.com/webcomponents/webcomponentsjs/blob/master/src/ShadowDOM/wrappers/HTMLElement.js#L28\r\n/////////////////////////////////////////////////////////////////////////////\r\n// innerHTML and outerHTML\r\n\r\n// http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#escapingString\r\nlet escapeAttrRegExp = /[&\\u00A0\"]/g;\r\nlet escapeDataRegExp = /[&\\u00A0<>]/g;\r\n\r\nfunction escapeReplace(c) {\r\n  switch (c) {\r\n    case '&':\r\n      return '&amp;';\r\n    case '<':\r\n      return '&lt;';\r\n    case '>':\r\n      return '&gt;';\r\n    case '\"':\r\n      return '&quot;';\r\n    case '\\u00A0':\r\n      return '&nbsp;';\r\n  }\r\n}\r\n\r\nfunction escapeAttr(s) {\r\n  return s.replace(escapeAttrRegExp, escapeReplace);\r\n}\r\n\r\nfunction escapeData(s) {\r\n  return s.replace(escapeDataRegExp, escapeReplace);\r\n}\r\n\r\nfunction makeSet(arr) {\r\n  let set = {};\r\n  for (let i = 0; i < arr.length; i++) {\r\n    set[arr[i]] = true;\r\n  }\r\n  return set;\r\n}\r\n\r\n// http://www.whatwg.org/specs/web-apps/current-work/#void-elements\r\nlet voidElements = makeSet([\r\n  'area',\r\n  'base',\r\n  'br',\r\n  'col',\r\n  'command',\r\n  'embed',\r\n  'hr',\r\n  'img',\r\n  'input',\r\n  'keygen',\r\n  'link',\r\n  'meta',\r\n  'param',\r\n  'source',\r\n  'track',\r\n  'wbr'\r\n]);\r\n\r\nlet plaintextParents = makeSet([\r\n  'style',\r\n  'script',\r\n  'xmp',\r\n  'iframe',\r\n  'noembed',\r\n  'noframes',\r\n  'plaintext',\r\n  'noscript'\r\n]);\r\n\r\nexport function getOuterHTML(node, parentNode, composed) {\r\n  switch (node.nodeType) {\r\n    case Node.ELEMENT_NODE: {\r\n      let tagName = node.localName;\r\n      let s = '<' + tagName;\r\n      let attrs = node.attributes;\r\n      for (let i = 0, attr; (attr = attrs[i]); i++) {\r\n        s += ' ' + attr.name + '=\"' + escapeAttr(attr.value) + '\"';\r\n      }\r\n      s += '>';\r\n      if (voidElements[tagName]) {\r\n        return s;\r\n      }\r\n      return s + getInnerHTML(node, composed) + '</' + tagName + '>';\r\n    }\r\n    case Node.TEXT_NODE: {\r\n      let data = node.data;\r\n      if (parentNode && plaintextParents[parentNode.localName]) {\r\n        return data;\r\n      }\r\n      return escapeData(data);\r\n    }\r\n    case Node.COMMENT_NODE: {\r\n      return '<!--' + node.data + '-->';\r\n    }\r\n    default: {\r\n      window.console.error(node);\r\n      throw new Error('not implemented');\r\n    }\r\n  }\r\n}\r\n\r\nexport function getInnerHTML(node, composed) {\r\n  if (node.localName === 'template') {\r\n    node = node.content;\r\n  }\r\n  let s = '';\r\n  let c$ = composed ? composed(node) : node.childNodes;\r\n  for (let i=0, l=c$.length, child; (i<l) && (child=c$[i]); i++) {\r\n    s += getOuterHTML(child, node, composed);\r\n  }\r\n  return s;\r\n}","/**\r\n@license\r\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\r\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\r\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\r\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\r\nCode distributed by Google as part of the polymer project is also\r\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\r\n*/\r\n\r\n'use strict';\r\n\r\nimport * as utils from './utils'\r\nimport {getInnerHTML} from './innerHTML'\r\nimport {tree} from './tree'\r\n\r\nlet mixinImpl = {\r\n\r\n  // Try to add node. Record logical info, track insertion points, perform\r\n  // distribution iff needed. Return true if the add is handled.\r\n  addNode(container, node, ref_node) {\r\n    let ownerRoot = this.ownerShadyRootForNode(container);\r\n    if (ownerRoot) {\r\n      // optimization: special insertion point tracking\r\n      if (node.__noInsertionPoint) {\r\n        ownerRoot._skipUpdateInsertionPoints = true;\r\n      }\r\n      // note: we always need to see if an insertion point is added\r\n      // since this saves logical tree info; however, invalidation state\r\n      // needs\r\n      let ipAdded = this._maybeAddInsertionPoint(node, container, ownerRoot);\r\n      // invalidate insertion points IFF not already invalid!\r\n      if (ipAdded) {\r\n        ownerRoot._skipUpdateInsertionPoints = false;\r\n      }\r\n      this._addedNode(node, ownerRoot);\r\n    }\r\n    if (tree.Logical.hasChildNodes(container)) {\r\n      tree.Logical.recordInsertBefore(node, container, ref_node);\r\n    }\r\n    // if not distributing and not adding to host, do a fast path addition\r\n    let handled = this._maybeDistribute(node, container, ownerRoot) ||\r\n      container.shadyRoot;\r\n    // TODO(sorvell): Can we do this cleanup code before distribution?\r\n    // if shady is handling this node,\r\n    // the actual dom may not be removed if the node or fragment contents\r\n    // remain undistributed so we ensure removal here.\r\n    // NOTE: we only remove from existing location iff shady dom is involved.\r\n    // This is because a node fragment is passed to the native add method\r\n    // which expects to see fragment children. Regular elements must also\r\n    // use this check because not doing so causes separation of\r\n    // attached/detached and breaks, for example,\r\n    // dom-if's attached/detached checks.\r\n    if (handled) {\r\n      if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\r\n        // TODO(sorvell): copy nodes ahead of time to avoid iloop\r\n        // that can occur when parent is not patched and child is...\r\n        let c$ = tree.arrayCopyChildNodes(node);\r\n        for (let i=0; i < c$.length; i++) {\r\n          tree.Composed.removeChild(node, c$[i]);\r\n        }\r\n      } else {\r\n        let parent = tree.Composed.getParentNode(node);\r\n        if (parent) {\r\n          tree.Composed.removeChild(parent, node);\r\n        }\r\n      }\r\n    }\r\n    return handled;\r\n  },\r\n\r\n  // Try to remove node: update logical info and perform distribution iff\r\n  // needed. Return true if the removal has been handled.\r\n  // note that it's possible for both the node's host and its parent\r\n  // to require distribution... both cases are handled here.\r\n  removeNode(node) {\r\n    // important that we want to do this only if the node has a logical parent\r\n    let logicalParent = tree.Logical.hasParentNode(node) &&\r\n      tree.Logical.getParentNode(node);\r\n    let distributed;\r\n    let ownerRoot = this.ownerShadyRootForNode(node);\r\n    if (logicalParent) {\r\n      // distribute node's parent iff needed\r\n      distributed = this.maybeDistributeParent(node);\r\n      tree.Logical.recordRemoveChild(node, logicalParent);\r\n      // remove node from root and distribute it iff needed\r\n      if (ownerRoot && (this._removeDistributedChildren(ownerRoot, node) ||\r\n        logicalParent.localName === ownerRoot.getInsertionPointTag())) {\r\n        ownerRoot._skipUpdateInsertionPoints = false;\r\n        ownerRoot.update();\r\n      }\r\n    }\r\n    this._removeOwnerShadyRoot(node);\r\n    if (ownerRoot) {\r\n      this._removedNode(node, ownerRoot);\r\n    }\r\n    return distributed;\r\n  },\r\n\r\n  removeNodeFromParent(node, parent) {\r\n    if (parent) {\r\n      // TODO(sorvell): notify\r\n      // if (DomApi.hasApi(parent)) {\r\n      //   dom(parent).notifyObserver();\r\n      // }\r\n      this.removeNode(node);\r\n    } else {\r\n      this._removeOwnerShadyRoot(node);\r\n    }\r\n  },\r\n\r\n  _hasCachedOwnerRoot(node) {\r\n    return Boolean(node.__ownerShadyRoot !== undefined);\r\n  },\r\n\r\n  getRootNode(node) {\r\n    if (!node || !node.nodeType) {\r\n      return;\r\n    }\r\n    let root = node.__ownerShadyRoot;\r\n    if (root === undefined) {\r\n      if (utils.isShadyRoot(node)) {\r\n        root = node;\r\n      } else {\r\n        let parent = tree.Logical.getParentNode(node);\r\n        root = parent ? this.getRootNode(parent) : node;\r\n      }\r\n      // memo-ize result for performance but only memo-ize\r\n      // result if node is in the document. This avoids a problem where a root\r\n      // can be cached while an element is inside a fragment.\r\n      // If this happens and we cache the result, the value can become stale\r\n      // because for perf we avoid processing the subtree of added fragments.\r\n      if (document.contains(node)) {\r\n        node.__ownerShadyRoot = root;\r\n      }\r\n    }\r\n    return root;\r\n  },\r\n\r\n  ownerShadyRootForNode(node) {\r\n    let root = this.getRootNode(node);\r\n    if (utils.isShadyRoot(root)) {\r\n      return root;\r\n    }\r\n  },\r\n\r\n  _maybeDistribute(node, container, ownerRoot) {\r\n    // TODO(sorvell): technically we should check non-fragment nodes for\r\n    // <content> children but since this case is assumed to be exceedingly\r\n    // rare, we avoid the cost and will address with some specific api\r\n    // when the need arises.  For now, the user must call\r\n    // distributeContent(true), which updates insertion points manually\r\n    // and forces distribution.\r\n    let insertionPointTag = ownerRoot && ownerRoot.getInsertionPointTag() || '';\r\n    let fragContent = (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) &&\r\n      !node.__noInsertionPoint &&\r\n      insertionPointTag && node.querySelector(insertionPointTag);\r\n    let wrappedContent = fragContent &&\r\n      (tree.Logical.getParentNode(fragContent).nodeType !==\r\n      Node.DOCUMENT_FRAGMENT_NODE);\r\n    let hasContent = fragContent || (node.localName === insertionPointTag);\r\n    // There are 3 possible cases where a distribution may need to occur:\r\n    // 1. <content> being inserted (the host of the shady root where\r\n    //    content is inserted needs distribution)\r\n    // 2. children being inserted into parent with a shady root (parent\r\n    //    needs distribution)\r\n    // 3. container is an insertionPoint\r\n    if (hasContent || (container.localName === insertionPointTag)) {\r\n      if (ownerRoot) {\r\n        // note, insertion point list update is handled after node\r\n        // mutations are complete\r\n        ownerRoot.update();\r\n      }\r\n    }\r\n    let needsDist = this._nodeNeedsDistribution(container);\r\n    if (needsDist) {\r\n      container.shadyRoot.update();\r\n    }\r\n    // Return true when distribution will fully handle the composition\r\n    // Note that if a content was being inserted that was wrapped by a node,\r\n    // and the parent does not need distribution, return false to allow\r\n    // the nodes to be added directly, after which children may be\r\n    // distributed and composed into the wrapping node(s)\r\n    return needsDist || (hasContent && !wrappedContent);\r\n  },\r\n\r\n  /* note: parent argument is required since node may have an out\r\n  of date parent at this point; returns true if a <content> is being added */\r\n  _maybeAddInsertionPoint(node, parent, root) {\r\n    let added;\r\n    let insertionPointTag = root.getInsertionPointTag();\r\n    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE &&\r\n      !node.__noInsertionPoint) {\r\n      let c$ = node.querySelectorAll(insertionPointTag);\r\n      for (let i=0, n, np, na; (i<c$.length) && (n=c$[i]); i++) {\r\n        np = tree.Logical.getParentNode(n);\r\n        // don't allow node's parent to be fragment itself\r\n        if (np === node) {\r\n          np = parent;\r\n        }\r\n        na = this._maybeAddInsertionPoint(n, np, root);\r\n        added = added || na;\r\n      }\r\n    } else if (node.localName === insertionPointTag) {\r\n      tree.Logical.saveChildNodes(parent);\r\n      tree.Logical.saveChildNodes(node);\r\n      added = true;\r\n    }\r\n    return added;\r\n  },\r\n\r\n  _nodeNeedsDistribution(node) {\r\n    return node && node.shadyRoot &&\r\n      node.shadyRoot.hasInsertionPoint();\r\n  },\r\n\r\n  // TODO(sorvell): needed for style scoping, use MO?\r\n  _addedNode() {},\r\n  _removedNode() {},\r\n  /*\r\n  _addedNode(node, root) {\r\n    // if (ShadyDOM.addedNode) {\r\n    //   ShadyDOM.addedNode(node, root);\r\n    // }\r\n  },\r\n\r\n  _removedNode(node, root) {\r\n    if (ShadyDOM.removedNode) {\r\n      ShadyDOM.removedNode(node, root);\r\n    }\r\n  },\r\n  */\r\n\r\n  _removeDistributedChildren(root, container) {\r\n    let hostNeedsDist;\r\n    let ip$ = root._insertionPoints;\r\n    for (let i=0; i<ip$.length; i++) {\r\n      let insertionPoint = ip$[i];\r\n      if (this._contains(container, insertionPoint)) {\r\n        let dc$ = insertionPoint.assignedNodes({flatten: true});\r\n        for (let j=0; j<dc$.length; j++) {\r\n          hostNeedsDist = true;\r\n          let node = dc$[j];\r\n          let parent = tree.Composed.getParentNode(node);\r\n          if (parent) {\r\n            tree.Composed.removeChild(parent, node);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return hostNeedsDist;\r\n  },\r\n\r\n  _contains(container, node) {\r\n    while (node) {\r\n      if (node == container) {\r\n        return true;\r\n      }\r\n      node = tree.Logical.getParentNode(node);\r\n    }\r\n  },\r\n\r\n  _removeOwnerShadyRoot(node) {\r\n    // optimization: only reset the tree if node is actually in a root\r\n    if (this._hasCachedOwnerRoot(node)) {\r\n      let c$ = tree.Logical.getChildNodes(node);\r\n      for (let i=0, l=c$.length, n; (i<l) && (n=c$[i]); i++) {\r\n        this._removeOwnerShadyRoot(n);\r\n      }\r\n    }\r\n    node.__ownerShadyRoot = undefined;\r\n  },\r\n\r\n  // TODO(sorvell): This will fail if distribution that affects this\r\n  // question is pending; this is expected to be exceedingly rare, but if\r\n  // the issue comes up, we can force a flush in this case.\r\n  firstComposedNode(insertionPoint) {\r\n    let n$ = insertionPoint.assignedNodes({flatten: true});\r\n    let root = this.getRootNode(insertionPoint);\r\n    for (let i=0, l=n$.length, n; (i<l) && (n=n$[i]); i++) {\r\n      // means that we're composed to this spot.\r\n      if (root.isFinalDestination(insertionPoint, n)) {\r\n        return n;\r\n      }\r\n    }\r\n  },\r\n\r\n  clearNode(node) {\r\n    while (node.firstChild) {\r\n      node.removeChild(node.firstChild);\r\n    }\r\n  },\r\n\r\n  maybeDistributeParent(node) {\r\n    let parent = tree.Logical.getParentNode(node);\r\n    if (this._nodeNeedsDistribution(parent)) {\r\n      parent.shadyRoot.update();\r\n      return true;\r\n    }\r\n  },\r\n\r\n  maybeDistributeAttributeChange(node, name) {\r\n    let distribute = (node.localName === 'slot' && name === 'name');\r\n    if (distribute) {\r\n      let root = this.getRootNode(node);\r\n      if (root.update) {\r\n        root.update();\r\n      }\r\n    }\r\n  },\r\n\r\n  // NOTE: `query` is used primarily for ShadyDOM's querySelector impl,\r\n  // but it's also generally useful to recurse through the element tree\r\n  // and is used by Polymer's styling system.\r\n  query(node, matcher, halter) {\r\n    let list = [];\r\n    this._queryElements(tree.Logical.getChildNodes(node), matcher,\r\n      halter, list);\r\n    return list;\r\n  },\r\n\r\n  _queryElements(elements, matcher, halter, list) {\r\n    for (let i=0, l=elements.length, c; (i<l) && (c=elements[i]); i++) {\r\n      if (c.nodeType === Node.ELEMENT_NODE &&\r\n          this._queryElement(c, matcher, halter, list)) {\r\n        return true;\r\n      }\r\n    }\r\n  },\r\n\r\n  _queryElement(node, matcher, halter, list) {\r\n    let result = matcher(node);\r\n    if (result) {\r\n      list.push(node);\r\n    }\r\n    if (halter && halter(result)) {\r\n      return result;\r\n    }\r\n    this._queryElements(tree.Logical.getChildNodes(node), matcher,\r\n      halter, list);\r\n  },\r\n\r\n  activeElementForNode(node) {\r\n    let active = document.activeElement;\r\n    if (!active) {\r\n      return null;\r\n    }\r\n    let isShadyRoot = !!(utils.isShadyRoot(node));\r\n    if (node !== document) {\r\n      // If this node isn't a document or shady root, then it doesn't have\r\n      // an active element.\r\n      if (!isShadyRoot) {\r\n        return null;\r\n      }\r\n      // If this shady root's host is the active element or the active\r\n      // element is not a descendant of the host (in the composed tree),\r\n      // then it doesn't have an active element.\r\n      if (node.host === active ||\r\n          !node.host.contains(active)) {\r\n        return null;\r\n      }\r\n    }\r\n    // This node is either the document or a shady root of which the active\r\n    // element is a (composed) descendant of its host; iterate upwards to\r\n    // find the active element's most shallow host within it.\r\n    let activeRoot = this.ownerShadyRootForNode(active);\r\n    while (activeRoot && activeRoot !== node) {\r\n      active = activeRoot.host;\r\n      activeRoot = this.ownerShadyRootForNode(active);\r\n    }\r\n    if (node === document) {\r\n      // This node is the document, so activeRoot should be null.\r\n      return activeRoot ? null : active;\r\n    } else {\r\n      // This node is a non-document shady root, and it should be\r\n      // activeRoot.\r\n      return activeRoot === node ? active : null;\r\n    }\r\n  }\r\n\r\n};\r\n\r\nlet nativeCloneNode = Element.prototype.cloneNode;\r\nlet nativeImportNode = Document.prototype.importNode;\r\nlet nativeSetAttribute = Element.prototype.setAttribute;\r\nlet nativeRemoveAttribute = Element.prototype.removeAttribute;\r\n\r\nlet NodeMixin = {};\r\n\r\nObject.defineProperties(NodeMixin, {\r\n\r\n  parentElement: {\r\n    get() {\r\n      return tree.Logical.getParentNode(this);\r\n    },\r\n    configurable: true\r\n  },\r\n\r\n  parentNode: {\r\n    get() {\r\n      return tree.Logical.getParentNode(this);\r\n    },\r\n    configurable: true\r\n  },\r\n\r\n  nextSibling: {\r\n    get() {\r\n      return tree.Logical.getNextSibling(this);\r\n    },\r\n    configurable: true\r\n  },\r\n\r\n  previousSibling: {\r\n    get() {\r\n      return tree.Logical.getPreviousSibling(this);\r\n    },\r\n    configurable: true\r\n  },\r\n\r\n  nextElementSibling: {\r\n    get() {\r\n      return tree.Logical.getNextElementSibling(this);\r\n    },\r\n    configurable: true\r\n  },\r\n\r\n  previousElementSibling: {\r\n    get() {\r\n      return tree.Logical.getPreviousElementSibling(this);\r\n    },\r\n    configurable: true\r\n  },\r\n\r\n  assignedSlot: {\r\n    get() {\r\n      return this._assignedSlot;\r\n    },\r\n    configurable: true\r\n  }\r\n});\r\n\r\nlet FragmentMixin = {\r\n\r\n  appendChild(node) {\r\n    return this.insertBefore(node);\r\n  },\r\n\r\n  // cases in which we may not be able to just do standard native call\r\n  // 1. container has a shadyRoot (needsDistribution IFF the shadyRoot\r\n  // has an insertion point)\r\n  // 2. container is a shadyRoot (don't distribute, instead set\r\n  // container to container.host.\r\n  // 3. node is <content> (host of container needs distribution)\r\n  insertBefore(node, ref_node) {\r\n    if (ref_node && tree.Logical.getParentNode(ref_node) !== this) {\r\n      throw Error('The ref_node to be inserted before is not a child ' +\r\n        'of this node');\r\n    }\r\n    // remove node from its current position iff it's in a tree.\r\n    if (node.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {\r\n      let parent = tree.Logical.getParentNode(node);\r\n      mixinImpl.removeNodeFromParent(node, parent);\r\n    }\r\n    if (!mixinImpl.addNode(this, node, ref_node)) {\r\n      if (ref_node) {\r\n        // if ref_node is an insertion point replace with first distributed node\r\n        // TODO(sorvell): v0/v1!!\r\n        let root = mixinImpl.ownerShadyRootForNode(ref_node);\r\n        if (root) {\r\n          ref_node = ref_node.localName === root.getInsertionPointTag() ?\r\n            mixinImpl.firstComposedNode(ref_node) : ref_node;\r\n        }\r\n      }\r\n      // if adding to a shadyRoot, add to host instead\r\n      let container = utils.isShadyRoot(this) ?\r\n        this.host : this;\r\n      if (ref_node) {\r\n        tree.Composed.insertBefore(container, node, ref_node);\r\n      } else {\r\n        tree.Composed.appendChild(container, node);\r\n      }\r\n    }\r\n    // TODO(sorvell): notify\r\n    //this.notifyObserver();\r\n    return node;\r\n  },\r\n\r\n  /**\r\n    Removes the given `node` from the element's `lightChildren`.\r\n    This method also performs dom composition.\r\n  */\r\n  removeChild(node) {\r\n    if (tree.Logical.getParentNode(node) !== this) {\r\n      throw Error('The node to be removed is not a child of this node: ' +\r\n        node);\r\n    }\r\n    if (!mixinImpl.removeNode(node)) {\r\n      // if removing from a shadyRoot, remove form host instead\r\n      let container = utils.isShadyRoot(this) ?\r\n        this.host :\r\n        this;\r\n      // not guaranteed to physically be in container; e.g.\r\n      // undistributed nodes.\r\n      let parent = tree.Composed.getParentNode(node);\r\n      if (container === parent) {\r\n        tree.Composed.removeChild(container, node);\r\n      }\r\n    }\r\n    // TODO(sorvell): notify\r\n    //this.notifyObserver();\r\n    return node;\r\n  },\r\n\r\n  replaceChild(node, ref_node) {\r\n    this.insertBefore(node, ref_node);\r\n    this.removeChild(ref_node);\r\n    return node;\r\n  },\r\n\r\n  // TODO(sorvell): consider doing native QSA and filtering results.\r\n  querySelector(selector) {\r\n    // match selector and halt on first result.\r\n    let result = mixinImpl.query(this, function(n) {\r\n      return utils.matchesSelector(n, selector);\r\n    }, function(n) {\r\n      return Boolean(n);\r\n    })[0];\r\n    return result || null;\r\n  },\r\n\r\n  querySelectorAll(selector) {\r\n    return mixinImpl.query(this, function(n) {\r\n      return utils.matchesSelector(n, selector);\r\n    });\r\n  },\r\n\r\n  cloneNode(deep) {\r\n    if (this.localName == 'template') {\r\n      return nativeCloneNode.call(this, deep);\r\n    } else {\r\n      let n = nativeCloneNode.call(this, false);\r\n      if (deep) {\r\n        let c$ = this.childNodes;\r\n        for (let i=0, nc; i < c$.length; i++) {\r\n          nc = c$[i].cloneNode(true);\r\n          n.appendChild(nc);\r\n        }\r\n      }\r\n      return n;\r\n    }\r\n  },\r\n\r\n  importNode(externalNode, deep) {\r\n    // for convenience use this node's ownerDoc if the node isn't a document\r\n    let doc = this instanceof Document ? this :\r\n      this.ownerDocument;\r\n    let n = nativeImportNode.call(doc, externalNode, false);\r\n    if (deep) {\r\n      let c$ = tree.Logical.getChildNodes(externalNode);\r\n      utils.common.patchNode(n);\r\n      for (let i=0, nc; i < c$.length; i++) {\r\n        nc = doc.importNode(c$[i], true);\r\n        n.appendChild(nc);\r\n      }\r\n    }\r\n    return n;\r\n  }\r\n};\r\n\r\nObject.defineProperties(FragmentMixin, {\r\n\r\n  childNodes: {\r\n    get() {\r\n      let c$ = tree.Logical.getChildNodes(this);\r\n      return Array.isArray(c$) ? c$ : tree.arrayCopyChildNodes(this);\r\n    },\r\n    configurable: true\r\n  },\r\n\r\n  children: {\r\n    get() {\r\n      if (tree.Logical.hasChildNodes(this)) {\r\n        return Array.prototype.filter.call(this.childNodes, function(n) {\r\n          return (n.nodeType === Node.ELEMENT_NODE);\r\n        });\r\n      } else {\r\n        return tree.arrayCopyChildren(this);\r\n      }\r\n    },\r\n    configurable: true\r\n  },\r\n\r\n  firstChild: {\r\n    get() {\r\n      return tree.Logical.getFirstChild(this);\r\n    },\r\n    configurable: true\r\n  },\r\n\r\n  lastChild: {\r\n    get() {\r\n      return tree.Logical.getLastChild(this);\r\n    },\r\n    configurable: true\r\n  },\r\n\r\n  firstElementChild: {\r\n    get() {\r\n      return tree.Logical.getFirstElementChild(this);\r\n    },\r\n    configurable: true\r\n  },\r\n\r\n  lastElementChild: {\r\n    get() {\r\n      return tree.Logical.getLastElementChild(this);\r\n    },\r\n    configurable: true\r\n  },\r\n\r\n  // TODO(srovell): strictly speaking fragments do not have textContent\r\n  // or innerHTML but ShadowRoots do and are not easily distinguishable.\r\n  // textContent / innerHTML\r\n  textContent: {\r\n    get() {\r\n      if (this.childNodes) {\r\n        let tc = [];\r\n        for (let i = 0, cn = this.childNodes, c; (c = cn[i]); i++) {\r\n          if (c.nodeType !== Node.COMMENT_NODE) {\r\n            tc.push(c.textContent);\r\n          }\r\n        }\r\n        return tc.join('');\r\n      }\r\n      return '';\r\n    },\r\n    set(text) {\r\n      mixinImpl.clearNode(this);\r\n      if (text) {\r\n        this.appendChild(document.createTextNode(text));\r\n      }\r\n    },\r\n    configurable: true\r\n  },\r\n\r\n  innerHTML: {\r\n    get() {\r\n      return getInnerHTML(this);\r\n    },\r\n    set(text) {\r\n      mixinImpl.clearNode(this);\r\n      let d = document.createElement('div');\r\n      d.innerHTML = text;\r\n      // here, appendChild may move nodes async so we cannot rely\r\n      // on node position when copying\r\n      let c$ = tree.arrayCopyChildNodes(d);\r\n      for (let i=0; i < c$.length; i++) {\r\n        this.appendChild(c$[i]);\r\n      }\r\n    },\r\n    configurable: true\r\n  }\r\n\r\n});\r\n\r\nlet ElementMixin = {\r\n\r\n  // TODO(sorvell): should only exist on <slot>\r\n  assignedNodes(options) {\r\n    return (options && options.flatten ? this._distributedNodes :\r\n      this._assignedNodes) || [];\r\n  },\r\n\r\n\r\n  setAttribute(name, value) {\r\n    nativeSetAttribute.call(this, name, value);\r\n    if (!mixinImpl.maybeDistributeParent(this)) {\r\n      mixinImpl.maybeDistributeAttributeChange(this, name);\r\n    }\r\n  },\r\n\r\n  removeAttribute(name) {\r\n    nativeRemoveAttribute.call(this, name);\r\n    if (!mixinImpl.maybeDistributeParent(this)) {\r\n      mixinImpl.maybeDistributeAttributeChange(this, name);\r\n    }\r\n  }\r\n\r\n};\r\n\r\nObject.defineProperties(ElementMixin, {\r\n\r\n  shadowRoot: {\r\n    get() {\r\n      return this.shadyRoot;\r\n    }\r\n  },\r\n\r\n  slot: {\r\n    get() {\r\n      return this.getAttribute('slot');\r\n    },\r\n    set(value) {\r\n      this.setAttribute('slot', value);\r\n    }\r\n  }\r\n\r\n});\r\n\r\nlet activeElementDescriptor = {\r\n  get() {\r\n    return mixinImpl.activeElementForNode(this);\r\n  }\r\n}\r\n\r\nlet ActiveElementMixin = {};\r\nObject.defineProperties(ActiveElementMixin, {\r\n  activeElement: activeElementDescriptor\r\n});\r\n\r\nlet UnderActiveElementMixin = {};\r\nObject.defineProperties(UnderActiveElementMixin, {\r\n  _activeElement: activeElementDescriptor\r\n});\r\n\r\nexport let Mixins = {\r\n\r\n  Node: utils.extendAll({__patched: 'Node'}, NodeMixin),\r\n\r\n  Fragment: utils.extendAll({__patched: 'Fragment'},\r\n    NodeMixin, FragmentMixin, ActiveElementMixin),\r\n\r\n  Element: utils.extendAll({__patched: 'Element'},\r\n    NodeMixin, FragmentMixin, ElementMixin, ActiveElementMixin),\r\n\r\n  // Note: activeElement cannot be patched on document!\r\n  Document: utils.extendAll({__patched: 'Document'},\r\n    NodeMixin, FragmentMixin, ElementMixin, UnderActiveElementMixin)\r\n\r\n};\r\n\r\nexport let getRootNode = mixinImpl.getRootNode;","/**\r\n@license\r\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\r\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\r\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\r\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\r\nCode distributed by Google as part of the polymer project is also\r\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\r\n*/\r\n\r\n'use strict';\r\n\r\nimport {calculateSplices} from './array-splice'\r\nimport * as utils from './utils'\r\nimport {tree} from './tree'\r\nimport Distributor from './distributor'\r\n\r\n/**\r\n  Implements a pared down version of ShadowDOM's scoping, which is easy to\r\n  polyfill across browsers.\r\n*/\r\nexport class ShadyRoot {\r\n\r\n  constructor(host) {\r\n    if (!host) {\r\n      throw 'Must provide a host';\r\n    }\r\n    // NOTE: this strange construction is necessary because\r\n    // DocumentFragment cannot be subclassed on older browsers.\r\n    let frag = document.createDocumentFragment();\r\n    frag.__proto__ = ShadyFragmentMixin;\r\n    frag._init(host);\r\n    return frag;\r\n  }\r\n\r\n}\r\n\r\nlet ShadyMixin = {\r\n\r\n  _init(host) {\r\n    // TODO(sorvell): set a fake local name so this element can be\r\n    // distinguished from a DocumentFragment when patching.\r\n    // FF doesn't allow this to be `localName`\r\n    this.__localName = 'ShadyRoot';\r\n    // root <=> host\r\n    host.shadyRoot = this;\r\n    this.host = host;\r\n    // logical dom setup\r\n    tree.Logical.saveChildNodes(host);\r\n    tree.Logical.saveChildNodes(this);\r\n    // state flags\r\n    this._clean = true;\r\n    this._hasRendered = false;\r\n    this._distributor = new Distributor(this);\r\n    this.update();\r\n  },\r\n\r\n  // async render the \"top\" distributor (this is all that is needed to\r\n  // distribute this host).\r\n  update() {\r\n    let distributionRoot = this._findDistributionRoot(this.host);\r\n    //console.log('update from', this.host, 'root', distributionRoot.host, distributionRoot._clean);\r\n    if (distributionRoot._clean) {\r\n      distributionRoot._clean = false;\r\n      enqueue(function() {\r\n        distributionRoot.render();\r\n      });\r\n    }\r\n  },\r\n\r\n  // returns the host that's the top of this host's distribution tree\r\n  _findDistributionRoot(element) {\r\n    let root = element.shadyRoot;\r\n    while (element && this._elementNeedsDistribution(element)) {\r\n      root = element.getRootNode();\r\n      element = root && root.host;\r\n    }\r\n    return root;\r\n  },\r\n\r\n  // Return true if a host's children includes\r\n  // an insertion point that selects selectively\r\n  _elementNeedsDistribution(element) {\r\n    let c$ = tree.Logical.getChildNodes(element);\r\n    for (let i=0, c; i < c$.length; i++) {\r\n      c = c$[i];\r\n      if (this._distributor.isInsertionPoint(c)) {\r\n        return element.getRootNode();\r\n      }\r\n    }\r\n  },\r\n\r\n  render() {\r\n    if (!this._clean) {\r\n      if (!this._skipUpdateInsertionPoints) {\r\n        this.updateInsertionPoints();\r\n      } else if (!this._hasRendered) {\r\n        this._insertionPoints = [];\r\n      }\r\n      this._skipUpdateInsertionPoints = false;\r\n      // TODO(sorvell): previous ShadyDom had a fast path here\r\n      // that would avoid distribution for initial render if\r\n      // no insertion points exist. We cannot currently do this because\r\n      // it relies on elements being in the physical shadowRoot element\r\n      // so that native methods will be used. The current append code\r\n      // simply provokes distribution in this case and does not put the\r\n      // nodes in the shadowRoot. This could be done but we'll need to\r\n      // consider if the special processing is worth the perf gain.\r\n      // if (!this._hasRendered && !this._insertionPoints.length) {\r\n      //   tree.Composed.clearChildNodes(this.host);\r\n      //   tree.Composed.appendChild(this.host, this);\r\n      // } else {\r\n      // logical\r\n      this.distribute();\r\n      // physical\r\n      this.compose();\r\n      // allow distributor to do post render tasks (e.g. fire events!)\r\n      this._distributor.rendered();\r\n      this._clean = true;\r\n      this._hasRendered = true;\r\n    }\r\n  },\r\n\r\n  forceRender() {\r\n    this._clean = false;\r\n    this.render();\r\n  },\r\n\r\n  distribute() {\r\n    let dirtyRoots = this._distributor.distribute();\r\n    for (let i=0; i<dirtyRoots.length; i++) {\r\n      dirtyRoots[i].forceRender();\r\n    }\r\n  },\r\n\r\n  updateInsertionPoints() {\r\n    let i$ = this._insertionPoints = this._distributor.getInsertionPoints();\r\n    // ensure insertionPoints's and their parents have logical dom info.\r\n    // save logical tree info\r\n    // a. for shadyRoot\r\n    // b. for insertion points (fallback)\r\n    // c. for parents of insertion points\r\n    for (let i=0, c; i < i$.length; i++) {\r\n      c = i$[i];\r\n      tree.Logical.saveChildNodes(c);\r\n      tree.Logical.saveChildNodes(tree.Logical.getParentNode(c));\r\n    }\r\n  },\r\n\r\n  get _insertionPoints() {\r\n    if (!this.__insertionPoints) {\r\n      this.updateInsertionPoints();\r\n    }\r\n    return this.__insertionPoints || (this.__insertionPoints = []);\r\n  },\r\n\r\n  set _insertionPoints(insertionPoints) {\r\n    this.__insertionPoints = insertionPoints;\r\n  },\r\n\r\n  hasInsertionPoint() {\r\n    return this._distributor.hasInsertionPoint();\r\n  },\r\n\r\n  compose() {\r\n    // compose self\r\n    // note: it's important to mark this clean before distribution\r\n    // so that attachment that provokes additional distribution (e.g.\r\n    // adding something to your parentNode) works\r\n    this._composeTree();\r\n    // TODO(sorvell): notification.\r\n    // NOTE: send a signal to insertion points that we have distributed\r\n    // which informs effective children observers\r\n    //notifyContentObservers(this);\r\n    // TODO(sorvell): See fast paths here in Polymer v1\r\n    // (these seem unnecessary)\r\n    // NOTE: send a signal to any observers\r\n    // to report the initial set of childNodes\r\n  },\r\n\r\n  // Reify dom such that it is at its correct rendering position\r\n  // based on logical distribution.\r\n  _composeTree() {\r\n    this._updateChildNodes(this.host, this._composeNode(this.host));\r\n    let p$ = this._insertionPoints || [];\r\n    for (let i=0, l=p$.length, p, parent; (i<l) && (p=p$[i]); i++) {\r\n      parent = tree.Logical.getParentNode(p);\r\n      if ((parent !== this.host) && (parent !== this)) {\r\n        this._updateChildNodes(parent, this._composeNode(parent));\r\n      }\r\n    }\r\n  },\r\n\r\n  // Returns the list of nodes which should be rendered inside `node`.\r\n  _composeNode(node) {\r\n    let children = [];\r\n    let c$ = tree.Logical.getChildNodes(node.shadyRoot || node);\r\n    for (let i = 0; i < c$.length; i++) {\r\n      let child = c$[i];\r\n      if (this._distributor.isInsertionPoint(child)) {\r\n        let distributedNodes = child._distributedNodes ||\r\n          (child._distributedNodes = []);\r\n        for (let j = 0; j < distributedNodes.length; j++) {\r\n          let distributedNode = distributedNodes[j];\r\n          if (this.isFinalDestination(child, distributedNode)) {\r\n            children.push(distributedNode);\r\n          }\r\n        }\r\n      } else {\r\n        children.push(child);\r\n      }\r\n    }\r\n    return children;\r\n  },\r\n\r\n  isFinalDestination(insertionPoint, node) {\r\n    return this._distributor.isFinalDestination(\r\n      insertionPoint, node);\r\n  },\r\n\r\n  // Ensures that the rendered node list inside `container` is `children`.\r\n  _updateChildNodes(container, children) {\r\n    let composed = tree.Composed.getChildNodes(container);\r\n    let splices = calculateSplices(children, composed);\r\n    // process removals\r\n    for (let i=0, d=0, s; (i<splices.length) && (s=splices[i]); i++) {\r\n      for (let j=0, n; (j < s.removed.length) && (n=s.removed[j]); j++) {\r\n        // check if the node is still where we expect it is before trying\r\n        // to remove it; this can happen if we move a node and\r\n        // then schedule its previous host for distribution resulting in\r\n        // the node being removed here.\r\n        if (tree.Composed.getParentNode(n) === container) {\r\n          tree.Composed.removeChild(container, n);\r\n        }\r\n        composed.splice(s.index + d, 1);\r\n      }\r\n      d -= s.addedCount;\r\n    }\r\n    // process adds\r\n    for (let i=0, s, next; (i<splices.length) && (s=splices[i]); i++) { //eslint-disable-line no-redeclare\r\n      next = composed[s.index];\r\n      for (let j=s.index, n; j < s.index + s.addedCount; j++) {\r\n        n = children[j];\r\n        tree.Composed.insertBefore(container, n, next);\r\n        // TODO(sorvell): is this splice strictly needed?\r\n        composed.splice(j, 0, n);\r\n      }\r\n    }\r\n  },\r\n\r\n  // TODO(sorvell): util\r\n  getInsertionPointTag() {\r\n    return this._distributor.insertionPointTag;\r\n  }\r\n\r\n}\r\n\r\nlet ShadyFragmentMixin = Object.create(DocumentFragment.prototype);\r\nutils.extend(ShadyFragmentMixin, ShadyMixin);\r\n\r\n// TODO(sorvell): observation...\r\n// function notifyContentObservers(root) {\r\n//   for (let i=0, c; i < root._insertionPoints.length; i++) {\r\n//     c = root._insertionPoints[i];\r\n//     if (DomApi.hasApi(c)) {\r\n//       Polymer.dom(c).notifyObserver();\r\n//     }\r\n//   }\r\n// }\r\n\r\n// function notifyInitialDistribution(host) {\r\n//   if (DomApi.hasApi(host)) {\r\n//     Polymer.dom(host).notifyObserver();\r\n//   }\r\n// }\r\n\r\n// let needsUpgrade = window.CustomElements && !CustomElements.useNative;\r\n\r\n// function upgradeLogicalChildren(children) {\r\n//   if (needsUpgrade && children) {\r\n//     for (let i=0; i < children.length; i++) {\r\n//       CustomElements.upgrade(children[i]);\r\n//     }\r\n//   }\r\n// }\r\n\r\n// render enqueuer/flusher\r\nlet customElements = window.CustomElements;\r\nlet flushList = [];\r\nlet scheduled;\r\nexport function enqueue(callback) {\r\n  if (!scheduled) {\r\n    scheduled = true;\r\n    Promise.resolve().then(flush);\r\n  }\r\n  flushList.push(callback);\r\n}\r\n\r\nexport function flush() {\r\n  while (flushList.length) {\r\n    flushList.shift()();\r\n  }\r\n  if (customElements) {\r\n    customElements.takeRecords();\r\n  }\r\n  // continue flushing after elements are upgraded...\r\n  if (flushList.length) {\r\n    flush();\r\n  }\r\n}","/**\r\n@license\r\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\r\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\r\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\r\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\r\nCode distributed by Google as part of the polymer project is also\r\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\r\n*/\r\n\r\n/**\r\n * Patches elements that interacts with ShadyDOM\r\n * such that tree traversal and mutation apis act like they would under\r\n * ShadowDOM.\r\n *\r\n * This import enables seemless interaction with ShadyDOM powered\r\n * custom elements, enabling better interoperation with 3rd party code,\r\n * libraries, and frameworks that use DOM tree manipulation apis.\r\n */\r\n\r\n'use strict';\r\nimport {tree} from './tree'\r\nimport * as utils from './utils'\r\nimport {Mixins} from './element-mixin'\r\n\r\nexport let patchedCount = 0;\r\n\r\nlet log = false;\r\n\r\nlet patchImpl = {\r\n\r\n  canPatchNode: function(node) {\r\n    switch (node) {\r\n      case document.head:\r\n      case document.documentElement:\r\n        return false;\r\n      default:\r\n        return true;\r\n    }\r\n  },\r\n\r\n  hasPrototypeDescriptors: Boolean(Object.getOwnPropertyDescriptor(\r\n    window.Node.prototype, 'textContent')),\r\n\r\n  patch: function(node) {\r\n    patchedCount++;\r\n    log && window.console.warn('patch node', node);\r\n    if (this.hasPrototypeDescriptors) {\r\n      utils.patchPrototype(node, this.mixinForObject(node));\r\n    } else {\r\n      window.console.warn('Patching instance rather than prototype', node);\r\n      utils.extend(node, this.mixinForNode(node));\r\n    }\r\n  },\r\n\r\n  mixinForObject: function(obj) {\r\n    switch (obj.nodeType) {\r\n      case Node.ELEMENT_NODE:\r\n        return Mixins.Element;\r\n      case Node.DOCUMENT_FRAGMENT_NODE:\r\n        return Mixins.Fragment;\r\n      case Node.DOCUMENT_NODE:\r\n        return Mixins.Document;\r\n      case Node.TEXT_NODE:\r\n      case Node.COMMENT_NODE:\r\n        return Mixins.Node;\r\n    }\r\n  },\r\n\r\n  unpatch: function(obj) {\r\n    if (obj.__sourceProto) {\r\n      obj.__proto__ = obj.__sourceProto;\r\n\r\n    }\r\n    // TODO(sorvell): implement unpatching for non-proto patchable browsers\r\n  }\r\n\r\n};\r\n\r\nexport function patchNode(node) {\r\n  if (!utils.settings.inUse) {\r\n    return;\r\n  }\r\n  if (!isNodePatched(node) && patchImpl.canPatchNode(node)) {\r\n    tree.saveChildNodes(node);\r\n    patchImpl.patch(node);\r\n  }\r\n}\r\n\r\nexport function unpatchNode(node) {\r\n  patchImpl.unpatch(node);\r\n}\r\n\r\nexport function isNodePatched(node) {\r\n  return Boolean(node.__patched);\r\n}\r\n\r\n// TODO(sorvell): fake export\r\nutils.common.patchNode = patchNode;","/**\r\n@license\r\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\r\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\r\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\r\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\r\nCode distributed by Google as part of the polymer project is also\r\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\r\n*/\r\n\r\n'use strict';\r\n\r\nimport * as utils from './utils'\r\n\r\nlet origAddEventListener = Element.prototype.addEventListener;\r\nlet origRemoveEventListener = Element.prototype.removeEventListener;\r\n\r\n// https://github.com/w3c/webcomponents/issues/513#issuecomment-224183937\r\nlet alwaysComposed = {\r\n  blur: true,\r\n  focus: true,\r\n  focusin: true,\r\n  focusout: true,\r\n  click: true,\r\n  dblclick: true,\r\n  mousedown: true,\r\n  mouseenter: true,\r\n  mouseleave: true,\r\n  mousemove: true,\r\n  mouseout: true,\r\n  mouseover: true,\r\n  mouseup: true,\r\n  wheel: true,\r\n  beforeinput: true,\r\n  input: true,\r\n  keydown: true,\r\n  keyup: true,\r\n  compositionstart: true,\r\n  compositionupdate: true,\r\n  compositionend: true,\r\n  touchstart: true,\r\n  touchend: true,\r\n  touchmove: true,\r\n  touchcancel: true,\r\n  pointerover: true,\r\n  pointerenter: true,\r\n  pointerdown: true,\r\n  pointermove: true,\r\n  pointerup: true,\r\n  pointercancel: true,\r\n  pointerout: true,\r\n  pointerleave: true,\r\n  gotpointercapture: true,\r\n  lostpointercapture: true,\r\n  dragstart: true,\r\n  drag: true,\r\n  dragenter: true,\r\n  dragleave: true,\r\n  dragover: true,\r\n  drop: true,\r\n  dragend: true,\r\n  DOMActivate: true,\r\n  DOMFocusIn: true,\r\n  DOMFocusOut: true,\r\n  keypress: true\r\n};\r\n\r\nfunction pathComposer(startNode, composed) {\r\n  let composedPath = [];\r\n  let current = startNode;\r\n  let startRoot = getRootNode(startNode);\r\n  while (current) {\r\n    composedPath.push(current);\r\n    if (current.assignedSlot) {\r\n      current = current.assignedSlot;\r\n    } else if (current.host && (composed || current !== startRoot)) {\r\n      current = current.host;\r\n    } else {\r\n      current = current.parentNode;\r\n    }\r\n  }\r\n  // event composedPath includes window when startNode's ownerRoot is document\r\n  if (composedPath[composedPath.length - 1] === document) {\r\n    composedPath.push(window);\r\n  }\r\n  return composedPath;\r\n}\r\n\r\nfunction retarget(refNode, path) {\r\n  if (!utils.isShadyRoot) {\r\n    return refNode;\r\n  }\r\n  // If ANCESTOR's root is not a shadow root or ANCESTOR's root is BASE's\r\n  // shadow-including inclusive ancestor, return ANCESTOR.\r\n  let refNodePath = pathComposer(refNode, true);\r\n  let p$ = path;\r\n  for (let i=0, ancestor, lastRoot, root, rootIdx; i < p$.length; i++) {\r\n    ancestor = p$[i];\r\n    root = getRootNode(ancestor);\r\n    if (root !== lastRoot) {\r\n      rootIdx = refNodePath.indexOf(root);\r\n      lastRoot = root;\r\n    }\r\n    if (!utils.isShadyRoot(root) || rootIdx > -1) {\r\n      return ancestor;\r\n    }\r\n  }\r\n}\r\n\r\nfunction getRootNode(node) {\r\n  return node === window || !node.getRootNode ? node : node.getRootNode();\r\n}\r\n\r\nlet EventMixin = {\r\n\r\n  __patched: 'Event',\r\n\r\n  get composed() {\r\n    if (this.isTrusted && this.__composed === undefined) {\r\n      this.__composed = alwaysComposed[this.type];\r\n    }\r\n    return this.__composed || false;\r\n  },\r\n\r\n  composedPath() {\r\n    if (!this.__composedPath) {\r\n      this.__composedPath = pathComposer(this.__target, this.composed);\r\n    }\r\n    return this.__composedPath;\r\n  },\r\n\r\n  get target() {\r\n    return retarget(this.currentTarget, this.composedPath());\r\n  },\r\n\r\n  // http://w3c.github.io/webcomponents/spec/shadow/#event-relatedtarget-retargeting\r\n  get relatedTarget() {\r\n    if (!this.__relatedTarget) {\r\n      return null;\r\n    }\r\n    if (!this.__relatedTargetComposedPath) {\r\n      this.__relatedTargetComposedPath = pathComposer(this.__relatedTarget, true);\r\n    }\r\n    // find the deepest node in relatedTarget composed path that is in the same root with the currentTarget\r\n    return retarget(this.currentTarget, this.__relatedTargetComposedPath);\r\n  },\r\n  stopPropagation() {\r\n    Event.prototype.stopPropagation.call(this);\r\n    this.__propagationStopped = true;\r\n  },\r\n  stopImmediatePropagation() {\r\n    Event.prototype.stopImmediatePropagation.call(this);\r\n    this.__immediatePropagationStopped = true;\r\n    this.__propagationStopped = true;\r\n  }\r\n\r\n};\r\n\r\nfunction mixinComposedFlag(Base) {\r\n  // NOTE: avoiding use of `class` here so that transpiled output does not\r\n  // try to do `Base.call` with a dom construtor.\r\n  let klazz = function(type, options) {\r\n    let event = new Base(type, options);\r\n    event.__composed = options && Boolean(options.composed);\r\n    return event;\r\n  }\r\n  // put constructor properties on subclass\r\n  utils.mixin(klazz, Base);\r\n  klazz.prototype = Base.prototype;\r\n  return klazz;\r\n}\r\n\r\nlet nonBubblingEventsToRetarget = {\r\n  focus: true,\r\n  blur: true\r\n};\r\n\r\nfunction fireHandlers(event, node, phase) {\r\n  let hs = node.__handlers && node.__handlers[event.type] &&\r\n    node.__handlers[event.type][phase];\r\n  if (hs) {\r\n    for (let i = 0, fn; (fn = hs[i]); i++) {\r\n      fn.call(node, event);\r\n      if (event.__immediatePropagationStopped) {\r\n        return;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction retargetNonBubblingEvent(e) {\r\n  let path = e.composedPath();\r\n  let node;\r\n  // override `currentTarget` to let patched `target` calculate correctly\r\n  Object.defineProperty(event, 'currentTarget', {\r\n    get: function() {\r\n      return node;\r\n    },\r\n    configurable: true\r\n  });\r\n  for (let i = path.length - 1; i >= 0; i--) {\r\n    node = path[i];\r\n    fireHandlers(e, node, 'capture');\r\n    if (e.__propagationStopped) {\r\n      return;\r\n    }\r\n  }\r\n  Object.defineProperty(e, 'eventPhase', {value: Event.BUBBLING_PHASE});\r\n  for (let i = 0; i < path.length; i++) {\r\n    node = path[i];\r\n    fireHandlers(e, node, 'bubble');\r\n    if (e.__propagationStopped) {\r\n      return;\r\n    }\r\n  }\r\n}\r\n\r\nfunction shouldCapture(optionsOrCapture) {\r\n  return Boolean(typeof optionsOrCapture === 'object' ?\r\n    optionsOrCapture.capture : optionsOrCapture);\r\n}\r\n\r\nexport function addEventListener(type, fn, optionsOrCapture) {\r\n  if (!fn) {\r\n    return;\r\n  }\r\n  // TODO: investigate if this is worth tracking, as it is only used for\r\n  // deciding if the `slotchanged` event should be fired\r\n  if (!this.__eventListenerCount) {\r\n    this.__eventListenerCount = 0;\r\n  }\r\n  this.__eventListenerCount++;\r\n  let wrappedFn = function(e) {\r\n    if (!e.__target) {\r\n      e.__target = e.target;\r\n      e.__relatedTarget = e.relatedTarget;\r\n      utils.patchPrototype(e, EventMixin);\r\n    }\r\n    // There are two critera that should stop events from firing on this node\r\n    // 1. the event is not composed and the current node is not in the same root as the target\r\n    // 2. when bubbling, if after retargeting, relatedTarget and target point to the same node\r\n    if (e.composed || e.composedPath().indexOf(this) > -1) {\r\n      if (e.eventPhase === Event.BUBBLING_PHASE) {\r\n        if (e.target === e.relatedTarget) {\r\n          e.stopImmediatePropagation();\r\n          return;\r\n        }\r\n      }\r\n      return fn(e);\r\n    }\r\n  };\r\n  fn.__eventWrapper = wrappedFn;\r\n  if (nonBubblingEventsToRetarget[type]) {\r\n    this.__handlers = this.__handlers || {};\r\n    this.__handlers[type] = this.__handlers[type] || {capture: [], bubble: []};\r\n    if (shouldCapture(optionsOrCapture)) {\r\n      this.__handlers[type].capture.push(wrappedFn);\r\n    } else {\r\n      this.__handlers[type].bubble.push(wrappedFn);\r\n    }\r\n  } else {\r\n    origAddEventListener.call(this, type, wrappedFn, optionsOrCapture);\r\n  }\r\n}\r\n\r\nexport function removeEventListener(type, fn, optionsOrCapture) {\r\n  if (!fn) {\r\n    return;\r\n  }\r\n  let wrapper = fn.__eventWrapper;\r\n  origRemoveEventListener.call(this, type, wrapper || fn, optionsOrCapture);\r\n  if (wrapper) {\r\n    fn.__eventWrapper = null;\r\n    this.__eventListenerCount--;\r\n    if (nonBubblingEventsToRetarget[type]) {\r\n      if (this.__handlers) {\r\n        if (this.__handlers[type]) {\r\n          let idx;\r\n          if (shouldCapture(optionsOrCapture)) {\r\n            idx = this.__handlers[type].capture.indexOf(wrapper);\r\n            if (idx > -1) {\r\n              this.__handlers[type].capture.splice(idx, 1);\r\n            }\r\n          } else {\r\n            idx = this.__handlers[type].bubble.indexOf(wrapper);\r\n            if (idx > -1) {\r\n              this.__handlers[type].bubble.splice(idx, 1);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfor (let ev in nonBubblingEventsToRetarget) {\r\n  window.addEventListener(ev, function(e) {\r\n    if (!e.__target) {\r\n      e.__target = e.target;\r\n      e.__relatedTarget = e.relatedTarget;\r\n      utils.patchPrototype(e, EventMixin);\r\n      retargetNonBubblingEvent(e);\r\n      e.stopImmediatePropagation();\r\n    }\r\n  }, true);\r\n}\r\n\r\nexport let OriginalEvent = Event;\r\nexport let PatchedEvent = mixinComposedFlag(Event);\r\nexport let PatchedCustomEvent = mixinComposedFlag(CustomEvent);\r\nexport let PatchedMouseEvent = mixinComposedFlag(MouseEvent);\r\n","/**\r\n@license\r\nCopyright (c) 2016 The Polymer Project Authors. All rights reserved.\r\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\r\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\r\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\r\nCode distributed by Google as part of the polymer project is also\r\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\r\n*/\r\n\r\n/**\r\n * Patches elements that interacts with ShadyDOM\r\n * such that tree traversal and mutation apis act like they would under\r\n * ShadowDOM.\r\n *\r\n * This import enables seemless interaction with ShadyDOM powered\r\n * custom elements, enabling better interoperation with 3rd party code,\r\n * libraries, and frameworks that use DOM tree manipulation apis.\r\n */\r\n\r\n'use strict';\r\nimport * as utils from './utils'\r\nimport {ShadyRoot, flush, enqueue} from './shady'\r\nimport * as patch from './patch'\r\nimport {getRootNode} from './element-mixin'\r\nimport * as events from './event-mixin'\r\n\r\nif (utils.settings.inUse) {\r\n\r\n  window.ShadyDOM = {\r\n    patch: patch.patchNode,\r\n    isPatched: patch.isNodePatched,\r\n    unpatch: patch.unpatchNode,\r\n    isShadyRoot: utils.isShadyRoot,\r\n    enqueue: enqueue,\r\n    flush: flush,\r\n    inUse: utils.settings.inUse\r\n  };\r\n\r\n  let createRootAndEnsurePatched = function(node) {\r\n    // TODO(sorvell): need to ensure ancestors are patched but this introduces\r\n    // a timing problem with gathering composed children.\r\n    // (1) currently the child list is crawled and patched when patching occurs\r\n    // (this needs to change)\r\n    // (2) we can only patch when an element has received its parsed children\r\n    // because we cannot detect them when inserted by parser.\r\n    // let ancestor = node;\r\n    // while (ancestor) {\r\n    //   patchNode(ancestor);\r\n    //   ancestor = ancestor.parentNode || ancestor.host;\r\n    // }\r\n    patch.patchNode(node);\r\n    let root = new ShadyRoot(node);\r\n    patch.patchNode(root);\r\n    return root;\r\n  }\r\n\r\n  Element.prototype.attachShadow = function() {\r\n    return createRootAndEnsurePatched(this);\r\n  }\r\n\r\n  Node.prototype.addEventListener = events.addEventListener;\r\n  Node.prototype.removeEventListener = events.removeEventListener;\r\n  Event = events.PatchedEvent;\r\n  CustomEvent = events.PatchedCustomEvent;\r\n  MouseEvent = events.PatchedMouseEvent;\r\n\r\n  Object.defineProperty(Node.prototype, 'isConnected', {\r\n    get() {\r\n      return document.contains(this);\r\n    },\r\n    configurable: true\r\n  });\r\n\r\n  Node.prototype.getRootNode = function(options) {\r\n    return getRootNode(this, options);\r\n  }\r\n\r\n  // TODO(sorvell): super experimental auto patching of document fragment\r\n  // via appendChild. This either needs to be expanded or contracted.\r\n  // DocumentFragment.prototype.appendChild = function(node) {\r\n  //   patchNode(this);\r\n  //   return this.appendChild(node);\r\n  // }\r\n\r\n}\r\n"],"sourceRoot":"/source/"}